import { Directive, ElementRef, HostBinding, Input, Renderer2 } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { updateClassList } from './layout-utils';
import { DBreakpoints } from './layout.types';
import { DScreenMediaQueryService } from './screen-media-query.service';
import * as i0 from "@angular/core";
import * as i1 from "./screen-media-query.service";
export class DFlexDirective {
    constructor(elementRef, renderer, screenQueryService) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.screenQueryService = screenQueryService;
        this.destroy$ = new Subject();
    }
    get flexRow() {
        return this.dFlexContainer === 'row';
    }
    get flexColumn() {
        return this.dFlexContainer === 'column';
    }
    get flex() {
        return !!this.dFlexContainer;
    }
    parseFlex(flex) {
        if (typeof flex === 'number') {
            return `${flex}`;
        }
        else if (typeof flex === 'string') {
            if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
                return `0 0 ${flex}`;
            }
        }
        return flex;
    }
    updateFlex(currentPoint) {
        let finalFlex = '';
        if (this.dFlex) {
            if (typeof this.dFlex === 'object') {
                for (const point of DBreakpoints) {
                    if (this.dFlex[point]) {
                        finalFlex = this.dFlex[point];
                    }
                    if (currentPoint === point) {
                        break;
                    }
                }
            }
            else {
                finalFlex = this.dFlex;
            }
        }
        this.renderer.setStyle(this.elementRef.nativeElement, 'flex', this.parseFlex(finalFlex));
    }
    ngOnInit() {
        this.screenQueryService.getPoint()
            .pipe(takeUntil(this.destroy$))
            .subscribe(({ currentPoint }) => {
            this.updateFlex(currentPoint);
        });
        updateClassList(this, this.elementRef, this.renderer);
    }
    ngOnChanges() {
        updateClassList(this, this.elementRef, this.renderer);
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
DFlexDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DFlexDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i1.DScreenMediaQueryService }], target: i0.ɵɵFactoryTarget.Directive });
DFlexDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: DFlexDirective, selector: "[dFlex], d-row, d-col", inputs: { dFlex: "dFlex", dFlexContainer: "dFlexContainer", dOrder: "dOrder", dAlign: "dAlign", dAlignSelf: "dAlignSelf", dJustify: "dJustify", dFlexWrap: "dFlexWrap" }, host: { properties: { "class.dl-flex-row": "this.flexRow", "class.dl-flex-column": "this.flexColumn", "class.dl-d-flex": "this.flex" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DFlexDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `[dFlex], d-row, d-col`,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.DScreenMediaQueryService }]; }, propDecorators: { flexRow: [{
                type: HostBinding,
                args: ['class.dl-flex-row']
            }], flexColumn: [{
                type: HostBinding,
                args: ['class.dl-flex-column']
            }], flex: [{
                type: HostBinding,
                args: ['class.dl-d-flex']
            }], dFlex: [{
                type: Input
            }], dFlexContainer: [{
                type: Input
            }], dOrder: [{
                type: Input
            }], dAlign: [{
                type: Input
            }], dAlignSelf: [{
                type: Input
            }], dJustify: [{
                type: Input
            }], dFlexWrap: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxleC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9kZXZ1aS9sYXlvdXQvZmxleC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBZ0MsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ILE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNqRCxPQUFPLEVBQXNCLFlBQVksRUFBZ0MsTUFBTSxnQkFBZ0IsQ0FBQztBQUNoRyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQzs7O0FBTXhFLE1BQU0sT0FBTyxjQUFjO0lBMEJ6QixZQUNVLFVBQXNCLEVBQ3RCLFFBQW1CLEVBQ25CLGtCQUE0QztRQUY1QyxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLGFBQVEsR0FBUixRQUFRLENBQVc7UUFDbkIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUEwQjtRQUw5QyxhQUFRLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQU03QixDQUFDO0lBN0JMLElBQXNDLE9BQU87UUFDM0MsT0FBTyxJQUFJLENBQUMsY0FBYyxLQUFLLEtBQUssQ0FBQztJQUN2QyxDQUFDO0lBQ0QsSUFBeUMsVUFBVTtRQUNqRCxPQUFPLElBQUksQ0FBQyxjQUFjLEtBQUssUUFBUSxDQUFDO0lBQzFDLENBQUM7SUFDRCxJQUFvQyxJQUFJO1FBQ3RDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDL0IsQ0FBQztJQXNCRCxTQUFTLENBQUMsSUFBUztRQUNqQixJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUM1QixPQUFPLEdBQUcsSUFBSSxFQUFFLENBQUM7U0FDbEI7YUFBTSxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUNuQyxJQUFJLDRCQUE0QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDM0MsT0FBTyxPQUFPLElBQUksRUFBRSxDQUFDO2FBQ3RCO1NBQ0Y7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxVQUFVLENBQUMsWUFBWTtRQUNyQixJQUFJLFNBQVMsR0FBb0IsRUFBRSxDQUFDO1FBQ3BDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNkLElBQUksT0FBTyxJQUFJLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTtnQkFDbEMsS0FBSyxNQUFNLEtBQUssSUFBSSxZQUFZLEVBQUU7b0JBQ2hDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTt3QkFDckIsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7cUJBQy9CO29CQUNELElBQUksWUFBWSxLQUFLLEtBQUssRUFBRTt3QkFDMUIsTUFBTTtxQkFDUDtpQkFDRjthQUNGO2lCQUFNO2dCQUNMLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2FBQ3hCO1NBQ0Y7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQzNGLENBQUM7SUFFRCxRQUFRO1FBQ04sSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRTthQUMvQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM5QixTQUFTLENBQUMsQ0FBQyxFQUFFLFlBQVksRUFBRSxFQUFFLEVBQUU7WUFDOUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNoQyxDQUFDLENBQUMsQ0FBQztRQUNMLGVBQWUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVELFdBQVc7UUFDVCxlQUFlLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzNCLENBQUM7OzJHQTdFVSxjQUFjOytGQUFkLGNBQWM7MkZBQWQsY0FBYztrQkFKMUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsdUJBQXVCO2lCQUNsQztnS0FHdUMsT0FBTztzQkFBNUMsV0FBVzt1QkFBQyxtQkFBbUI7Z0JBR1MsVUFBVTtzQkFBbEQsV0FBVzt1QkFBQyxzQkFBc0I7Z0JBR0MsSUFBSTtzQkFBdkMsV0FBVzt1QkFBQyxpQkFBaUI7Z0JBSXJCLEtBQUs7c0JBQWIsS0FBSztnQkFHRyxjQUFjO3NCQUF0QixLQUFLO2dCQUVHLE1BQU07c0JBQWQsS0FBSztnQkFDRyxNQUFNO3NCQUFkLEtBQUs7Z0JBQ0csVUFBVTtzQkFBbEIsS0FBSztnQkFDRyxRQUFRO3NCQUFoQixLQUFLO2dCQUdHLFNBQVM7c0JBQWpCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyB1cGRhdGVDbGFzc0xpc3QgfSBmcm9tICcuL2xheW91dC11dGlscyc7XG5pbXBvcnQgeyBEQWxpZ24sIERBbGlnblNlbGYsIERCcmVha3BvaW50cywgREp1c3RpZnksIERSZXNwb25zZVBhcmFtZXRlciB9IGZyb20gJy4vbGF5b3V0LnR5cGVzJztcbmltcG9ydCB7IERTY3JlZW5NZWRpYVF1ZXJ5U2VydmljZSB9IGZyb20gJy4vc2NyZWVuLW1lZGlhLXF1ZXJ5LnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IGBbZEZsZXhdLCBkLXJvdywgZC1jb2xgLFxufSlcblxuZXhwb3J0IGNsYXNzIERGbGV4RGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIEBIb3N0QmluZGluZygnY2xhc3MuZGwtZmxleC1yb3cnKSBnZXQgZmxleFJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5kRmxleENvbnRhaW5lciA9PT0gJ3Jvdyc7XG4gIH1cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5kbC1mbGV4LWNvbHVtbicpIGdldCBmbGV4Q29sdW1uKCkge1xuICAgIHJldHVybiB0aGlzLmRGbGV4Q29udGFpbmVyID09PSAnY29sdW1uJztcbiAgfVxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmRsLWQtZmxleCcpIGdldCBmbGV4KCkge1xuICAgIHJldHVybiAhIXRoaXMuZEZsZXhDb250YWluZXI7XG4gIH1cblxuICBASW5wdXQoKSBkRmxleDogRFJlc3BvbnNlUGFyYW1ldGVyPG51bWJlciB8IHN0cmluZz47XG5cbiAgLyogVE9ETzog6L+Z5Liq5Lmf6ZyA6KaB5ZON5bqU5byPICovXG4gIEBJbnB1dCgpIGRGbGV4Q29udGFpbmVyOiAncm93JyB8ICdjb2x1bW4nO1xuXG4gIEBJbnB1dCgpIGRPcmRlcjogRFJlc3BvbnNlUGFyYW1ldGVyPG51bWJlcj47XG4gIEBJbnB1dCgpIGRBbGlnbjogRFJlc3BvbnNlUGFyYW1ldGVyPERBbGlnbj47XG4gIEBJbnB1dCgpIGRBbGlnblNlbGY6IERSZXNwb25zZVBhcmFtZXRlcjxEQWxpZ25TZWxmPjtcbiAgQElucHV0KCkgZEp1c3RpZnk6IERSZXNwb25zZVBhcmFtZXRlcjxESnVzdGlmeT47XG5cbiAgLyogVE9ET++8muWunueOsOi/meS4queJueaApyAqL1xuICBASW5wdXQoKSBkRmxleFdyYXA6IERSZXNwb25zZVBhcmFtZXRlcjxzdHJpbmc+O1xuXG4gIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBzY3JlZW5RdWVyeVNlcnZpY2U6IERTY3JlZW5NZWRpYVF1ZXJ5U2VydmljZVxuICApIHsgfVxuICBwYXJzZUZsZXgoZmxleDogYW55KTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIGZsZXggPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gYCR7ZmxleH1gO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZsZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoL15cXGQrKFxcLlxcZCspPyhweHxlbXxyZW18JSkkLy50ZXN0KGZsZXgpKSB7XG4gICAgICAgIHJldHVybiBgMCAwICR7ZmxleH1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmxleDtcbiAgfVxuXG4gIHVwZGF0ZUZsZXgoY3VycmVudFBvaW50KSB7XG4gICAgbGV0IGZpbmFsRmxleDogbnVtYmVyIHwgc3RyaW5nID0gJyc7XG4gICAgaWYgKHRoaXMuZEZsZXgpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5kRmxleCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBEQnJlYWtwb2ludHMpIHtcbiAgICAgICAgICBpZiAodGhpcy5kRmxleFtwb2ludF0pIHtcbiAgICAgICAgICAgIGZpbmFsRmxleCA9IHRoaXMuZEZsZXhbcG9pbnRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudFBvaW50ID09PSBwb2ludCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbEZsZXggPSB0aGlzLmRGbGV4O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZmxleCcsIHRoaXMucGFyc2VGbGV4KGZpbmFsRmxleCkpO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5zY3JlZW5RdWVyeVNlcnZpY2UuZ2V0UG9pbnQoKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgLnN1YnNjcmliZSgoeyBjdXJyZW50UG9pbnQgfSkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUZsZXgoY3VycmVudFBvaW50KTtcbiAgICAgIH0pO1xuICAgIHVwZGF0ZUNsYXNzTGlzdCh0aGlzLCB0aGlzLmVsZW1lbnRSZWYsIHRoaXMucmVuZGVyZXIpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoKTogdm9pZCB7XG4gICAgdXBkYXRlQ2xhc3NMaXN0KHRoaXMsIHRoaXMuZWxlbWVudFJlZiwgdGhpcy5yZW5kZXJlcik7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gIH1cbn1cbiJdfQ==