import { Directive, Input } from '@angular/core';
import { ActivatedRoute, NavigationEnd, Router } from '@angular/router';
import { Subscription } from 'rxjs';
import { debounceTime, filter } from 'rxjs/operators';
import { AnchorBoxDirective } from './anchor-box.directive';
import { AnchorLinkDirective } from './anchor-link.directive';
import * as i0 from "@angular/core";
import * as i1 from "./anchor-box.directive";
import * as i2 from "@angular/router";
export class AnchorBoxHashSupportDirective {
    constructor(box, router, route) {
        this.box = box;
        this.router = router;
        this.route = route;
        this.updateUrlWhenAnchorActive = true;
        this.scrollToAnchorByHashOnlyInit = false;
        this.sub = new Subscription();
        this.manual = false;
        this.navigateToHash = (targetAnchor) => {
            if (targetAnchor.activeChangeBy === 'initial') {
                return;
            }
            this.router.navigate([], { fragment: targetAnchor.anchor, replaceUrl: true });
            this.manual = true;
        };
        this.navigateToAnchor = (event) => {
            if (this.manual) {
                this.manual = false;
                return;
            }
            if (this.scrollToAnchorByHashOnlyInit) {
                return;
            }
            const frag = this.router.parseUrl(event.url).fragment;
            this.scrollToFragment(frag);
        };
        this.scrollToFragment = (frag) => {
            if (!frag) {
                return;
            }
            if (this.box.anchorMap[frag]) {
                const tempAnchor = new AnchorLinkDirective(this.box);
                tempAnchor.anchorName = frag;
                tempAnchor.anchorBlock = this.box.anchorMap[frag];
                tempAnchor.scrollToAnchor('fragment');
            }
        };
    }
    ngOnInit() {
        this.sub.add(this.box.activeChange.pipe(debounceTime(300), filter(anchor => this.updateUrlWhenAnchorActive)).subscribe(this.navigateToHash));
        this.sub.add(this.router.events.pipe(filter(event => event instanceof NavigationEnd)).subscribe(this.navigateToAnchor));
    }
    ngAfterViewInit() {
        const frag = this.route.snapshot.fragment;
        setTimeout(() => {
            this.scrollToFragment(frag);
        }, 120);
    }
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
}
AnchorBoxHashSupportDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: AnchorBoxHashSupportDirective, deps: [{ token: i1.AnchorBoxDirective }, { token: i2.Router }, { token: i2.ActivatedRoute }], target: i0.ɵɵFactoryTarget.Directive });
AnchorBoxHashSupportDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: AnchorBoxHashSupportDirective, selector: "[dAnchorBox][dAnchorHashSupport]", inputs: { updateUrlWhenAnchorActive: "updateUrlWhenAnchorActive", scrollToAnchorByHashOnlyInit: "scrollToAnchorByHashOnlyInit" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: AnchorBoxHashSupportDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dAnchorBox][dAnchorHashSupport]'
                }]
        }], ctorParameters: function () { return [{ type: i1.AnchorBoxDirective }, { type: i2.Router }, { type: i2.ActivatedRoute }]; }, propDecorators: { updateUrlWhenAnchorActive: [{
                type: Input
            }], scrollToAnchorByHashOnlyInit: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5jaG9yLWJveC1oYXNoLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2RldnVpL2FuY2hvci9hbmNob3ItYm94LWhhc2guZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBaUIsU0FBUyxFQUFFLEtBQUssRUFBb0MsTUFBTSxlQUFlLENBQUM7QUFDbEcsT0FBTyxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDeEUsT0FBTyxFQUFFLFlBQVksRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUNuQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDOzs7O0FBTTlELE1BQU0sT0FBTyw2QkFBNkI7SUFNeEMsWUFBb0IsR0FBdUIsRUFBVSxNQUFjLEVBQVUsS0FBcUI7UUFBOUUsUUFBRyxHQUFILEdBQUcsQ0FBb0I7UUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQVUsVUFBSyxHQUFMLEtBQUssQ0FBZ0I7UUFMekYsOEJBQXlCLEdBQUcsSUFBSSxDQUFDO1FBQ2pDLGlDQUE0QixHQUFHLEtBQUssQ0FBQztRQUM5QyxRQUFHLEdBQWlCLElBQUksWUFBWSxFQUFFLENBQUM7UUFDdkMsV0FBTSxHQUFHLEtBQUssQ0FBQztRQThCZixtQkFBYyxHQUFHLENBQUMsWUFBNkIsRUFBRSxFQUFFO1lBQ2pELElBQUksWUFBWSxDQUFDLGNBQWMsS0FBSyxTQUFTLEVBQUU7Z0JBQUUsT0FBTzthQUFFO1lBQzFELElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxZQUFZLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQzlFLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1FBQ3JCLENBQUMsQ0FBQztRQUVGLHFCQUFnQixHQUFHLENBQUMsS0FBb0IsRUFBRSxFQUFFO1lBQzFDLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDZixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztnQkFDcEIsT0FBTzthQUNSO1lBQ0QsSUFBSSxJQUFJLENBQUMsNEJBQTRCLEVBQUU7Z0JBQUUsT0FBTzthQUFFO1lBQ2xELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFDdEQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlCLENBQUMsQ0FBQztRQUVGLHFCQUFnQixHQUFHLENBQUMsSUFBWSxFQUFFLEVBQUU7WUFDbEMsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFBRSxPQUFPO2FBQUU7WUFDdEIsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDNUIsTUFBTSxVQUFVLEdBQUcsSUFBSSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3JELFVBQVUsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO2dCQUM3QixVQUFVLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNsRCxVQUFVLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ3ZDO1FBQ0gsQ0FBQyxDQUFDO0lBcERtRyxDQUFDO0lBRXRHLFFBQVE7UUFDTixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3JDLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFDakIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLENBQ2pELENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO1FBRWxDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDbEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxZQUFZLGFBQWEsQ0FBQyxDQUNoRCxDQUFDLFNBQVMsQ0FDVCxJQUFJLENBQUMsZ0JBQWdCLENBQ3RCLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxlQUFlO1FBQ2IsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBQzFDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7WUFDZCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUIsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ1YsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDWixJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3hCO0lBQ0gsQ0FBQzs7MEhBaENVLDZCQUE2Qjs4R0FBN0IsNkJBQTZCOzJGQUE3Qiw2QkFBNkI7a0JBSHpDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGtDQUFrQztpQkFDN0M7MkpBRVUseUJBQXlCO3NCQUFqQyxLQUFLO2dCQUNHLDRCQUE0QjtzQkFBcEMsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyVmlld0luaXQsIERpcmVjdGl2ZSwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSwgTmF2aWdhdGlvbkVuZCwgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEFuY2hvckJveERpcmVjdGl2ZSB9IGZyb20gJy4vYW5jaG9yLWJveC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQW5jaG9yTGlua0RpcmVjdGl2ZSB9IGZyb20gJy4vYW5jaG9yLWxpbmsuZGlyZWN0aXZlJztcbmltcG9ydCB7IEFuY2hvckRpcmVjdGl2ZSB9IGZyb20gJy4vYW5jaG9yLmRpcmVjdGl2ZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tkQW5jaG9yQm94XVtkQW5jaG9ySGFzaFN1cHBvcnRdJ1xufSlcbmV4cG9ydCBjbGFzcyBBbmNob3JCb3hIYXNoU3VwcG9ydERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgQElucHV0KCkgdXBkYXRlVXJsV2hlbkFuY2hvckFjdGl2ZSA9IHRydWU7XG4gIEBJbnB1dCgpIHNjcm9sbFRvQW5jaG9yQnlIYXNoT25seUluaXQgPSBmYWxzZTtcbiAgc3ViOiBTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gIG1hbnVhbCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYm94OiBBbmNob3JCb3hEaXJlY3RpdmUsIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsIHByaXZhdGUgcm91dGU6IEFjdGl2YXRlZFJvdXRlKSB7fVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuc3ViLmFkZCh0aGlzLmJveC5hY3RpdmVDaGFuZ2UucGlwZShcbiAgICAgIGRlYm91bmNlVGltZSgzMDApLFxuICAgICAgZmlsdGVyKGFuY2hvciA9PiB0aGlzLnVwZGF0ZVVybFdoZW5BbmNob3JBY3RpdmUpXG4gICAgKS5zdWJzY3JpYmUodGhpcy5uYXZpZ2F0ZVRvSGFzaCkpO1xuXG4gICAgdGhpcy5zdWIuYWRkKHRoaXMucm91dGVyLmV2ZW50cy5waXBlKFxuICAgICAgZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZClcbiAgICApLnN1YnNjcmliZShcbiAgICAgIHRoaXMubmF2aWdhdGVUb0FuY2hvclxuICAgICkpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLnJvdXRlLnNuYXBzaG90LmZyYWdtZW50O1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zY3JvbGxUb0ZyYWdtZW50KGZyYWcpO1xuICAgIH0sIDEyMCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdWIpIHtcbiAgICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgbmF2aWdhdGVUb0hhc2ggPSAodGFyZ2V0QW5jaG9yOiBBbmNob3JEaXJlY3RpdmUpID0+IHtcbiAgICBpZiAodGFyZ2V0QW5jaG9yLmFjdGl2ZUNoYW5nZUJ5ID09PSAnaW5pdGlhbCcpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5yb3V0ZXIubmF2aWdhdGUoW10sIHsgZnJhZ21lbnQ6IHRhcmdldEFuY2hvci5hbmNob3IsIHJlcGxhY2VVcmw6IHRydWUgfSk7XG4gICAgdGhpcy5tYW51YWwgPSB0cnVlO1xuICB9O1xuXG4gIG5hdmlnYXRlVG9BbmNob3IgPSAoZXZlbnQ6IE5hdmlnYXRpb25FbmQpID0+IHtcbiAgICBpZiAodGhpcy5tYW51YWwpIHtcbiAgICAgIHRoaXMubWFudWFsID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnNjcm9sbFRvQW5jaG9yQnlIYXNoT25seUluaXQpIHsgcmV0dXJuOyB9XG4gICAgY29uc3QgZnJhZyA9IHRoaXMucm91dGVyLnBhcnNlVXJsKGV2ZW50LnVybCkuZnJhZ21lbnQ7XG4gICAgdGhpcy5zY3JvbGxUb0ZyYWdtZW50KGZyYWcpO1xuICB9O1xuXG4gIHNjcm9sbFRvRnJhZ21lbnQgPSAoZnJhZzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFmcmFnKSB7IHJldHVybjsgfVxuICAgIGlmICh0aGlzLmJveC5hbmNob3JNYXBbZnJhZ10pIHtcbiAgICAgIGNvbnN0IHRlbXBBbmNob3IgPSBuZXcgQW5jaG9yTGlua0RpcmVjdGl2ZSh0aGlzLmJveCk7XG4gICAgICB0ZW1wQW5jaG9yLmFuY2hvck5hbWUgPSBmcmFnO1xuICAgICAgdGVtcEFuY2hvci5hbmNob3JCbG9jayA9IHRoaXMuYm94LmFuY2hvck1hcFtmcmFnXTtcbiAgICAgIHRlbXBBbmNob3Iuc2Nyb2xsVG9BbmNob3IoJ2ZyYWdtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuIl19