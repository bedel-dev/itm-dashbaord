import { AfterViewInit, ElementRef, EventEmitter, NgZone, OnDestroy, OnInit, Renderer2 } from '@angular/core';
import { Subject, Subscription } from 'rxjs';
import { DragDropService } from '../services/drag-drop.service';
import { PreserveNextEventEmitter } from './../shared/preserve-next-event-emitter';
import { DragPreviewDirective } from './drag-preview.directive';
import * as i0 from "@angular/core";
export declare class DraggableDirective implements OnInit, AfterViewInit, OnDestroy {
    el: ElementRef;
    private renderer;
    private dragDropService;
    private ngZone;
    dragPreviewDirective: DragPreviewDirective;
    private doc;
    draggable: boolean;
    /**
     * The data that will be available to the droppable directive on its `dropEvent()` event.
     */
    dragData: any;
    /**
     * The selector that defines the drag Handle. If defined drag will only be allowed if dragged from the selector element.
     */
    dragHandle: string;
    /**
     * Currently not used
     */
    dragEffect: string;
    /**
     * Defines compatible drag drop pairs. Values must match both in draggable and droppable.dropScope.
     */
    dragScope: string | Array<string>;
    dragHandleClass: string;
    /**
     * CSS class applied on the draggable that is applied when the item is being dragged.
     */
    dragOverClass: string;
    /**
     * Event fired when Drag is started
     */
    dragStartEvent: EventEmitter<any>;
    /**
     * @deprecated
     * Event fired while the element is being dragged
     * 为了性能优化，该函数废弃，请用(drag)自行监听， 如果不需要angular脏检测则最好用runOutsideAngular的addEventListener监听以获得好的性能
     */
    dragEvent: PreserveNextEventEmitter<any>;
    /**
     * Event fired when dragged ends
     */
    dragEndEvent: EventEmitter<any>;
    /**
     * Keeps track of mouse over element that is used to determine drag handles
     */
    private mouseOverElement;
    dropEndEvent: PreserveNextEventEmitter<any>;
    get disabled(): boolean;
    set disabled(value: boolean);
    private _disabled;
    enableDragFollow: boolean;
    dragFollowOptions: {
        appendToBody?: boolean;
    };
    originPlaceholder: {
        show?: boolean;
        tag?: string;
        style?: {
            [cssProperties: string]: string;
        };
        text?: string;
        removeDelay?: number;
    };
    dragIdentity: any;
    dragItemParentName: string;
    dragItemChildrenName: string;
    dragsSub: Subscription;
    destroyDragEndSub: Subscription;
    isDestroyed: boolean;
    private delayRemoveOriginPlaceholderTimer;
    batchDraggable: any;
    private dragOriginPlaceholder;
    private dragOriginPlaceholderNextSibling;
    dragElShowHideEvent: Subject<boolean>;
    beforeDragStartEvent: Subject<boolean>;
    document: Document;
    constructor(el: ElementRef, renderer: Renderer2, dragDropService: DragDropService, ngZone: NgZone, dragPreviewDirective: DragPreviewDirective, doc: any);
    ngOnInit(): void;
    dropSubscription(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    dragStart(e: any): void;
    dragEnd(e: any): void;
    mouseover(e: any): void;
    private allowDrag;
    private applyDragHandleClass;
    private getDragHandleElement;
    private mousePosition;
    insertOriginPlaceholder: (directShow?: boolean, updateService?: boolean) => void;
    removeOriginPlaceholder: (updateService?: boolean) => void;
    delayRemoveOriginPlaceholder: (updateService?: boolean) => void;
    findNextSibling(currentNextSibling: any): any;
    private checkAndGetViewPointChange;
    static ɵfac: i0.ɵɵFactoryDeclaration<DraggableDirective, [null, null, null, null, { optional: true; self: true; }, null]>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DraggableDirective, "[dDraggable]", never, { "dragData": "dragData"; "dragHandle": "dragHandle"; "dragEffect": "dragEffect"; "dragScope": "dragScope"; "dragHandleClass": "dragHandleClass"; "dragOverClass": "dragOverClass"; "disabled": "disabled"; "enableDragFollow": "enableDragFollow"; "dragFollowOptions": "dragFollowOptions"; "originPlaceholder": "originPlaceholder"; "dragIdentity": "dragIdentity"; "dragItemParentName": "dragItemParentName"; "dragItemChildrenName": "dragItemChildrenName"; }, { "dragStartEvent": "dragStartEvent"; "dragEvent": "dragEvent"; "dragEndEvent": "dragEndEvent"; "dropEndEvent": "dropEndEvent"; }, never>;
}
