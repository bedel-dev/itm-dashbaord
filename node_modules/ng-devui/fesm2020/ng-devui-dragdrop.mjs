import * as i1 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { ElementRef, Injectable, Inject, EventEmitter, Component, Directive, Input, Optional, Self, HostBinding, Output, QueryList, HostListener, NgModule } from '@angular/core';
import { Subject, Subscription, fromEvent, BehaviorSubject, merge } from 'rxjs';
import * as i1$1 from 'ng-devui/overlay-container';
import { debounceTime, tap, throttleTime, filter, distinctUntilChanged } from 'rxjs/operators';

class Utils {
    /**
     * Polyfill for element.matches.
     * See: https://developer.mozilla.org/en/docs/Web/API/Element/matches#Polyfill
     * element
     */
    static matches(element, selectorName) {
        const proto = Element.prototype;
        const func = proto['matches'] ||
            proto.matchesSelector ||
            proto.mozMatchesSelector ||
            proto.msMatchesSelector ||
            proto.oMatchesSelector ||
            proto.webkitMatchesSelector ||
            function (s) {
                const matches = (this.document || this.ownerDocument).querySelectorAll(s);
                let i = matches.length;
                while (--i >= 0 && matches.item(i) !== this) {
                    // do nothing
                }
                return i > -1;
            };
        return func.call(element, selectorName);
    }
    /**
     * Applies the specified css class on nativeElement
     * elementRef
     * className
     */
    static addClass(elementRef, className) {
        if (className === undefined) {
            return;
        }
        const e = this.getElementWithValidClassList(elementRef);
        if (e) {
            e.classList.add(className);
        }
    }
    /**
     * Removes the specified class from nativeElement
     * elementRef
     * className
     */
    static removeClass(elementRef, className) {
        if (className === undefined) {
            return;
        }
        const e = this.getElementWithValidClassList(elementRef);
        if (e) {
            e.classList.remove(className);
        }
    }
    /**
     * Gets element with valid classList
     *
     * elementRef
     * @returns ElementRef | null
     */
    static getElementWithValidClassList(elementRef) {
        const e = elementRef instanceof ElementRef ? elementRef.nativeElement : elementRef;
        if (e.classList !== undefined && e.classList !== null) {
            return e;
        }
        return null;
    }
    static slice(args, slice, sliceEnd) {
        const ret = [];
        let len = args.length;
        if (len === 0) {
            return ret;
        }
        const start = slice < 0
            ? Math.max(0, slice + len)
            : slice || 0;
        if (sliceEnd !== undefined) {
            len = sliceEnd < 0
                ? sliceEnd + len
                : sliceEnd;
        }
        while (len-- > start) {
            ret[len - start] = args[len];
        }
        return ret;
    }
    // 动态添加styles
    static addElStyles(el, styles) {
        if (styles instanceof Object) {
            for (const s in styles) {
                if (Object.prototype.hasOwnProperty.call(styles, s)) {
                    if (Array.isArray(styles[s])) {
                        // 用于支持兼容渐退
                        styles[s].forEach(val => {
                            el.style[s] = val;
                        });
                    }
                    else {
                        el.style[s] = styles[s];
                    }
                }
            }
        }
    }
    static dispatchEventToUnderElement(event, target, eventType) {
        const up = target || (event.target);
        up.style.display = 'none';
        const { x, y } = { x: event.clientX, y: event.clientY };
        const under = document.elementFromPoint(x, y);
        up.style.display = '';
        if (!under) {
            return event;
        }
        const ev = document.createEvent('DragEvent');
        ev.initMouseEvent(eventType || event.type, true, true, window, 0, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);
        if (ev.dataTransfer !== null) {
            ev.dataTransfer.setData('text', '');
            ev.dataTransfer.effectAllowed = event.dataTransfer.effectAllowed;
        }
        under.dispatchEvent(ev);
        return event;
    }
}

/**
 * 2020.03.23-Modified from https://github.com/Bernardo-Castilho/dragdroptouch, license: MIT，reason:Converting .js file to .ts file
 */
class DragDropTouch {
    constructor() {
        this.lastClick = 0;
        // ** event handlers
        this.touchstart = (e) => {
            if (this.shouldHandle(e)) {
                // raise double-click and prevent zooming
                if (Date.now() - this.lastClick < DragDropTouch.DBLCLICK) {
                    if (this.dispatchEvent(e, 'dblclick', e.target)) {
                        e.preventDefault();
                        this.reset();
                        return;
                    }
                }
                // clear all variables
                this.reset();
                // get nearest draggable element
                const src = this.closestDraggable(e.target);
                if (src) {
                    this.dragSource = src;
                    this.ptDown = this.getPoint(e);
                    this.lastTouch = e;
                    if (DragDropTouch.IS_PRESS_HOLD_MODE) {
                        this.pressHoldInterval = setTimeout(() => {
                            this.bindTouchmoveTouchend(e);
                            this.isDragEnabled = true;
                            this.touchmove(e);
                        }, DragDropTouch.PRESS_HOLD_AWAIT);
                    }
                    else {
                        e.preventDefault();
                        this.bindTouchmoveTouchend(e);
                    }
                }
            }
        };
        this.touchmoveOnDocument = (e) => {
            if (this.shouldCancelPressHoldMove(e)) {
                this.reset();
                return;
            }
        };
        this.touchmove = (e) => {
            if (this.shouldCancelPressHoldMove(e)) {
                this.reset();
                return;
            }
            if (this.shouldHandleMove(e) || this.shouldHandlePressHoldMove(e)) {
                const target = this.getTarget(e);
                // start dragging
                if (this.dragSource && !this.img && this.shouldStartDragging(e)) {
                    this.dispatchEvent(e, 'dragstart', this.dragSource);
                    this.createImage(e);
                }
                // continue dragging
                if (this.img) {
                    this.clearDragoverInterval();
                    this.lastTouch = e;
                    e.preventDefault(); // prevent scrolling
                    if (target !== this.lastTarget) {
                        // according to drag drop implementation of the browser, dragenterB is supposed to fired before dragleaveA
                        this.dispatchEvent(e, 'dragenter', target);
                        this.dispatchEvent(this.lastTouch, 'dragleave', this.lastTarget);
                        this.lastTarget = target;
                    }
                    this.moveImage(e);
                    this.isDropZone = this.dispatchEvent(e, 'dragover', target);
                    // should continue dispatch dragover event when touch position stay still
                    this.setDragoverInterval(e);
                }
            }
        };
        this.touchendOnDocument = (e) => {
            if (this.shouldHandle(e)) {
                if (!this.img) {
                    this.dragSource = null;
                    this.lastClick = Date.now();
                }
                // finish dragging
                this.destroyImage();
                if (this.dragSource) {
                    this.reset();
                }
            }
        };
        this.touchend = (e) => {
            if (this.shouldHandle(e)) {
                // user clicked the element but didn't drag, so clear the source and simulate a click
                if (!this.img) {
                    this.dragSource = null;
                    // browser will dispatch click event after trigger touchend, since touchstart didn't preventDefault
                    this.lastClick = Date.now();
                }
                // finish dragging
                this.destroyImage();
                if (this.dragSource) {
                    if (e.type.indexOf('cancel') < 0 && this.isDropZone) {
                        this.dispatchEvent(this.lastTouch, 'drop', this.lastTarget);
                    }
                    this.dispatchEvent(this.lastTouch, 'dragend', this.dragSource);
                    this.reset();
                }
            }
        };
        // enforce singleton pattern
        if (DragDropTouch.instance) {
            throw new Error('DragDropTouch instance already created.');
        }
        // detect passive event support
        // https://github.com/Modernizr/Modernizr/issues/1894
        let supportsPassive = false;
        if (typeof document !== 'undefined') {
            document.addEventListener('test', () => { }, {
                get passive() {
                    supportsPassive = true;
                    return true;
                }
            });
            // listen to touch events
            if (DragDropTouch.isTouchDevice()) {
                // 能响应触摸事件
                const d = document;
                const ts = this.touchstart;
                const tmod = this.touchmoveOnDocument;
                const teod = this.touchendOnDocument;
                const opt = supportsPassive ? { passive: false, capture: false } : false;
                const optPassive = supportsPassive ? { passive: true } : false;
                d.addEventListener('touchstart', ts, opt);
                d.addEventListener('touchmove', tmod, optPassive);
                d.addEventListener('touchend', teod);
                d.addEventListener('touchcancel', teod);
                this.touchmoveListener = this.touchmove;
                this.touchendListener = this.touchend;
                this.listenerOpt = opt;
            }
        }
    }
    /**
     * Gets a reference to the @see:DragDropTouch singleton.
     */
    static getInstance() {
        if (!DragDropTouch.instance) {
            DragDropTouch.instance = new DragDropTouch();
        }
        return DragDropTouch.instance;
    }
    static isTouchDevice() {
        if (typeof window === 'undefined' || typeof document === 'undefined') {
            return false;
        }
        const d = document;
        const w = window;
        let bool;
        if ('ontouchstart' in d // normal mobile device
            || 'ontouchstart' in w
            || navigator.maxTouchPoints > 0
            || navigator['msMaxTouchPoints'] > 0
            || window['DocumentTouch'] && document instanceof window['DocumentTouch']) {
            bool = true;
        }
        else {
            const fakeBody = document.createElement('fakebody');
            fakeBody.innerHTML += `
      <style>
        @media (touch-enabled),(-webkit-touch-enabled),(-moz-touch-enabled),(-o-touch-enabled){
          #touch_test {
            top: 42px;
            position: absolute;
          }
        }
      </style>`;
            document.documentElement.appendChild(fakeBody);
            const touchTestNode = document.createElement('div');
            touchTestNode.id = 'touch_test';
            fakeBody.appendChild(touchTestNode);
            bool = touchTestNode.offsetTop === 42;
            fakeBody.parentElement.removeChild(fakeBody);
        }
        return bool;
    }
    // ** event listener binding
    bindTouchmoveTouchend(e) {
        this.touchTarget = e.target;
        e.target.addEventListener('touchmove', this.touchmoveListener, this.listenerOpt);
        e.target.addEventListener('touchend', this.touchendListener);
        e.target.addEventListener('touchcancel', this.touchendListener);
    }
    removeTouchmoveTouchend() {
        if (this.touchTarget) {
            this.touchTarget.removeEventListener('touchmove', this.touchmoveListener);
            this.touchTarget.removeEventListener('touchend', this.touchendListener);
            this.touchTarget.removeEventListener('touchcancel', this.touchendListener);
            this.touchTarget = undefined;
        }
    }
    // ** utilities
    // ignore events that have been handled or that involve more than one touch
    shouldHandle(e) {
        return e &&
            !e.defaultPrevented &&
            e.touches && e.touches.length < 2;
    }
    // use regular condition outside of press & hold mode
    shouldHandleMove(e) {
        return !DragDropTouch.IS_PRESS_HOLD_MODE && this.shouldHandle(e);
    }
    // allow to handle moves that involve many touches for press & hold
    shouldHandlePressHoldMove(e) {
        return DragDropTouch.IS_PRESS_HOLD_MODE &&
            this.isDragEnabled && e && e.touches && e.touches.length;
    }
    // reset data if user drags without pressing & holding
    shouldCancelPressHoldMove(e) {
        return DragDropTouch.IS_PRESS_HOLD_MODE && !this.isDragEnabled &&
            this.getDelta(e) > DragDropTouch.PRESS_HOLD_MARGIN;
    }
    // start dragging when mouseover element matches drag handler selector and specified delta is detected
    shouldStartDragging(e) {
        const dragHandleSelector = this.getDragHandle();
        // start dragging when mouseover element matches drag handler selector
        if (dragHandleSelector && !this.matchSelector(e.target, dragHandleSelector)) {
            return false;
        }
        // start dragging when specified delta is detected
        const delta = this.getDelta(e);
        return delta > DragDropTouch.THRESHOLD ||
            (DragDropTouch.IS_PRESS_HOLD_MODE && delta >= DragDropTouch.PRESS_HOLD_THRESHOLD);
    }
    // find drag handler selector for dragstart only with partial element
    getDragHandle() {
        if (this.dragSource) {
            return this.dragSource.getAttribute(DragDropTouch.DRAG_HANDLE_ATTR) || '';
        }
        return '';
    }
    // test if element matches selector
    matchSelector(element, selector) {
        if (selector) {
            const proto = Element.prototype;
            const func = proto['matches'] ||
                proto['matchesSelector'] ||
                proto['mozMatchesSelector'] ||
                proto['msMatchesSelector'] ||
                proto['oMatchesSelector'] ||
                proto['webkitMatchesSelector'] ||
                function (s) {
                    const matches = (this.document || this.ownerDocument).querySelectorAll(s);
                    let i = matches.length;
                    while (--i >= 0 && matches.item(i) !== this) {
                        // do nothing
                    }
                    return i > -1;
                };
            return func.call(element, selector);
        }
        return true;
    }
    // clear all members
    reset() {
        this.removeTouchmoveTouchend();
        this.destroyImage();
        this.dragSource = null;
        this.lastTouch = null;
        this.lastTarget = null;
        this.ptDown = null;
        this.isDragEnabled = false;
        this.isDropZone = false;
        this.dataTransfer = new DragDropTouch.DataTransfer();
        clearInterval(this.pressHoldInterval);
        this.clearDragoverInterval();
    }
    // get point for a touch event
    getPoint(e, page) {
        if (e && e.touches) {
            e = e.touches[0];
        }
        return { x: page ? e.pageX : e.clientX, y: page ? e.pageY : e.clientY };
    }
    // get distance between the current touch event and the first one
    getDelta(e) {
        if (DragDropTouch.IS_PRESS_HOLD_MODE && !this.ptDown) {
            return 0;
        }
        const p = this.getPoint(e);
        return Math.abs(p.x - this.ptDown.x) + Math.abs(p.y - this.ptDown.y);
    }
    // get the element at a given touch event
    getTarget(e) {
        const pt = this.getPoint(e);
        let el = document.elementFromPoint(pt.x, pt.y);
        while (el && getComputedStyle(el).pointerEvents === 'none') {
            el = el.parentElement;
        }
        return el;
    }
    // create drag image from source element
    createImage(e) {
        // just in case...
        if (this.img) {
            this.destroyImage();
        }
        // create drag image from custom element or drag source
        const src = this.imgCustom || this.dragSource;
        this.img = src.cloneNode(true);
        this.copyStyle(src, this.img);
        this.img.style.top = this.img.style.left = '-9999px';
        // if creating from drag source, apply offset and opacity
        if (!this.imgCustom) {
            const rc = src.getBoundingClientRect();
            const pt = this.getPoint(e);
            this.imgOffset = { x: pt.x - rc.left, y: pt.y - rc.top };
            this.img.style.opacity = DragDropTouch.OPACITY.toString();
        }
        // add image to document
        this.moveImage(e);
        document.body.appendChild(this.img);
    }
    // dispose of drag image element
    destroyImage() {
        if (this.img && this.img.parentElement) {
            this.img.parentElement.removeChild(this.img);
        }
        this.img = null;
        this.imgCustom = null;
    }
    // move the drag image element
    moveImage(e) {
        requestAnimationFrame(() => {
            if (this.img) {
                const pt = this.getPoint(e, true);
                const s = this.img.style;
                s.position = 'absolute';
                s.pointerEvents = 'none';
                s.zIndex = '999999';
                s.left = Math.round(pt.x - this.imgOffset.x) + 'px';
                s.top = Math.round(pt.y - this.imgOffset.y) + 'px';
            }
        });
    }
    // copy properties from an object to another
    copyProps(dst, src, props) {
        for (let i = 0; i < props.length; i++) {
            const p = props[i];
            dst[p] = src[p];
        }
    }
    // copy styles/attributes from drag source to drag image element
    copyStyle(src, dst) {
        // remove potentially troublesome attributes
        DragDropTouch.rmvAttrs.forEach(function (att) {
            dst.removeAttribute(att);
        });
        // copy canvas content
        if (src instanceof HTMLCanvasElement) {
            const canSrc = src;
            const canDst = dst;
            canDst.width = canSrc.width;
            canDst.height = canSrc.height;
            canDst.getContext('2d').drawImage(canSrc, 0, 0);
        }
        // copy canvas content for nested canvas element
        const srcCanvases = src.querySelectorAll('canvas');
        if (srcCanvases.length > 0) {
            const dstCanvases = dst.querySelectorAll('canvas');
            for (let i = 0; i < dstCanvases.length; i++) {
                const cSrc = srcCanvases[i];
                const cDst = dstCanvases[i];
                cDst.getContext('2d').drawImage(cSrc, 0, 0);
            }
        }
        // copy style (without transitions)
        const cs = getComputedStyle(src);
        for (let i = 0; i < cs.length; i++) {
            const key = cs[i];
            if (key.indexOf('transition') < 0) {
                dst.style[key] = cs[key];
            }
        }
        dst.style.pointerEvents = 'none';
        // and repeat for all children
        for (let i = 0; i < src.children.length; i++) {
            this.copyStyle(src.children[i], dst.children[i]);
        }
    }
    // synthesize and dispatch an event
    // returns true if the event has been handled (e.preventDefault == true)
    dispatchEvent(e, type, target) {
        if (e && target) {
            const evt = document.createEvent('Event');
            const t = e.touches ? e.touches[0] : e;
            evt.initEvent(type, true, true);
            const obj = {
                button: 0,
                which: 0,
                buttons: 1,
                dataTransfer: this.dataTransfer
            };
            this.copyProps(evt, e, DragDropTouch.kbdProps);
            this.copyProps(evt, t, DragDropTouch.ptProps);
            this.copyProps(evt, { fromTouch: true }, ['fromTouch']); // mark as from touch event
            this.copyProps(evt, obj, Object.keys(obj));
            target.dispatchEvent(evt);
            return evt.defaultPrevented;
        }
        return false;
    }
    // gets an element's closest draggable ancestor
    closestDraggable(e) {
        for (; e; e = e.parentElement) {
            if (e.hasAttribute('draggable') && e.draggable) {
                return e;
            }
        }
        return null;
    }
    // repeat dispatch dragover event when touch point stay still
    setDragoverInterval(e) {
        this.dragoverTimer = setInterval(() => {
            const target = this.getTarget(e);
            if (target !== this.lastTarget) {
                this.dispatchEvent(e, 'dragenter', target);
                this.dispatchEvent(e, 'dragleave', this.lastTarget);
                this.lastTarget = target;
            }
            this.isDropZone = this.dispatchEvent(e, 'dragover', target);
        }, DragDropTouch.DRAG_OVER_TIME);
    }
    clearDragoverInterval() {
        if (this.dragoverTimer) {
            clearInterval(this.dragoverTimer);
            this.dragoverTimer = undefined;
        }
    }
}
DragDropTouch.THRESHOLD = 5; // pixels to move before drag starts
DragDropTouch.OPACITY = 0.5; // drag image opacity
DragDropTouch.DBLCLICK = 500; // max ms between clicks in a double click
DragDropTouch.DRAG_OVER_TIME = 300; // interval ms when drag over
DragDropTouch.CTX_MENU = 900; // ms to hold before raising 'contextmenu' event
DragDropTouch.IS_PRESS_HOLD_MODE = true; // decides of press & hold mode presence
DragDropTouch.PRESS_HOLD_AWAIT = 400; // ms to wait before press & hold is detected
DragDropTouch.PRESS_HOLD_MARGIN = 25; // pixels that finger might shiver while pressing
DragDropTouch.PRESS_HOLD_THRESHOLD = 0; // pixels to move before drag starts
DragDropTouch.DRAG_HANDLE_ATTR = 'data-drag-handle-selector';
DragDropTouch.rmvAttrs = 'id,class,style,draggable'.split(',');
DragDropTouch.kbdProps = 'altKey,ctrlKey,metaKey,shiftKey'.split(',');
DragDropTouch.ptProps = 'pageX,pageY,clientX,clientY,screenX,screenY'.split(',');
DragDropTouch.instance = null;
/* eslint-disable-next-line @typescript-eslint/no-namespace */
(function (DragDropTouch) {
    /**
       * Object used to hold the data that is being dragged during drag and drop operations.
       *
       * It may hold one or more data items of different types. For more information about
       * drag and drop operations and data transfer objects, see
       * <a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer">HTML Drag and Drop API</a>.
       *
       * This object is created automatically by the @see:DragDropTouch singleton and is
       * accessible through the @see:dataTransfer property of all drag events.
       */
    class DataTransfer {
        constructor() {
            this._dropEffect = 'move';
            this._effectAllowed = 'all';
            this._data = {};
        }
        get dropEffect() {
            return this._dropEffect;
        }
        set dropEffect(value) {
            this._dropEffect = value;
        }
        get effectAllowed() {
            return this._effectAllowed;
        }
        set effectAllowed(value) {
            this._effectAllowed = value;
        }
        get types() {
            return Object.keys(this._data);
        }
        /**
           * Removes the data associated with a given type.
           *
           * The type argument is optional. If the type is empty or not specified, the data
           * associated with all types is removed. If data for the specified type does not exist,
           * or the data transfer contains no data, this method will have no effect.
           *
           * @param type Type of data to remove.
           */
        clearData(type) {
            if (type !== null) {
                delete this._data[type];
            }
            else {
                this._data = null;
            }
        }
        /**
         * Retrieves the data for a given type, or an empty string if data for that type does
         * not exist or the data transfer contains no data.
         *
         * @param type Type of data to retrieve.
         */
        getData(type) {
            return this._data[type] || '';
        }
        /**
         * Set the data for a given type.
         *
         * For a list of recommended drag types, please see
         * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Recommended_Drag_Types.
         *
         * @param type Type of data to add.
         * @param value Data to add.
         */
        setData(type, value) {
            this._data[type] = value;
        }
        /**
         * Set the image to be used for dragging if a custom one is desired.
         *
         * @param img An image element to use as the drag feedback image.
         * @param offsetX The horizontal offset within the image.
         * @param offsetY The vertical offset within the image.
         */
        setDragImage(img, offsetX, offsetY) {
            const ddt = DragDropTouch.getInstance();
            ddt.imgCustom = img;
            ddt.imgOffset = { x: offsetX, y: offsetY };
        }
    }
    DragDropTouch.DataTransfer = DataTransfer;
})(DragDropTouch || (DragDropTouch = {}));

class DragDropService {
    constructor(ngZone, doc) {
        this.ngZone = ngZone;
        this.doc = doc;
        this.dropTargets = [];
        this.dropEvent = new Subject();
        this.dragEndEvent = new Subject();
        this.dragStartEvent = new Subject();
        this.subscription = new Subscription();
        this.dragEmptyImage = new Image();
        this.dragItemParentName = '';
        this.dragItemChildrenName = '';
        this.intersectionObserver = null;
        /* 协同拖拽需要 */
        this.dragElShowHideEvent = new Subject();
        this.followMouse4CloneNode = (event) => {
            const { offsetLeft, offsetTop } = this.dragOffset;
            const { clientX, clientY } = event;
            requestAnimationFrame(() => {
                if (!this.dragCloneNode) {
                    return;
                }
                this.dragCloneNode.style.left = clientX - offsetLeft + 'px';
                this.dragCloneNode.style.top = clientY - offsetTop + 'px';
            });
        };
        this.touchInstance = DragDropTouch.getInstance();
        // service not support OnInit, only support OnDestroy, so write in constructor
        // safari的img必须要有src
        this.dragEmptyImage.src
            = 'data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==';
        this.document = this.doc;
    }
    newSubscription() {
        this.subscription.unsubscribe();
        // eslint-disable-next-line no-return-assign
        return this.subscription = new Subscription();
    }
    enableDraggedCloneNodeFollowMouse() {
        if (!this.dragCloneNode) {
            this.dragItemContainer = this.draggedEl.parentElement;
            if (this.dragPreviewDirective && this.dragPreviewDirective.dragPreviewTemplate) {
                this.dragPreviewDirective.createPreview();
                this.dragCloneNode = this.dragPreviewDirective.getPreviewElement();
                this.dragItemContainer = this.document.body;
            }
            else {
                this.dragCloneNode = this.draggedEl.cloneNode(true);
            }
            this.dragCloneNode.style.margin = '0';
            if (this.dragFollowOptions && this.dragFollowOptions.appendToBody) {
                this.dragItemContainer = this.document.body;
                this.copyStyle(this.draggedEl, this.dragCloneNode);
            }
            if (this.dragItemChildrenName !== '') {
                const parentElement = this.dragItemParentName === '' ? this.dragCloneNode : this.document.querySelector(this.dragItemParentName);
                const dragItemChildren = parentElement.querySelectorAll(this.dragItemChildrenName);
                this.interceptChildNode(parentElement, dragItemChildren);
            }
            // 拷贝canvas的内容
            const originCanvasArr = this.draggedEl.querySelectorAll('canvas');
            const targetCanvasArr = this.dragCloneNode.querySelectorAll('canvas');
            [].forEach.call(targetCanvasArr, (canvas, index) => {
                canvas.getContext('2d').drawImage(originCanvasArr[index], 0, 0);
            });
            this.ngZone.runOutsideAngular(() => {
                this.document.addEventListener('dragover', this.followMouse4CloneNode, { capture: true, passive: true });
            });
            this.dragCloneNode.style.width = this.dragOffset.width + 'px';
            this.dragCloneNode.style.height = this.dragOffset.height + 'px';
            if (!(this.dragPreviewDirective
                && this.dragPreviewDirective.dragPreviewTemplate
                && this.dragPreviewDirective.dragPreviewOptions
                && this.dragPreviewDirective.dragPreviewOptions.skipBatchPreview)) {
                // 批量拖拽样式
                if (this.batchDragging && this.batchDragData && this.batchDragData.length > 1) {
                    // 创建一个节点容器
                    const node = this.document.createElement('div');
                    node.appendChild(this.dragCloneNode);
                    node.classList.add('batch-dragged-node');
                    /* 计数样式定位 */
                    if (this.batchDragStyle && this.batchDragStyle.length && this.batchDragStyle.indexOf('badge') > -1) {
                        const badge = this.document.createElement('div');
                        badge.innerText = String(this.batchDragData.length);
                        badge.classList.add('batch-dragged-node-count');
                        node.style.position = 'relative';
                        const style = {
                            position: 'absolute',
                            right: '5px',
                            top: '-12px',
                            height: '24px',
                            width: '24px',
                            borderRadius: '12px',
                            fontSize: '14px',
                            lineHeight: '24px',
                            textAlign: 'center',
                            color: '#fff',
                            background: ['#5170ff', 'var(--brand-1, #5170ff)']
                        };
                        Utils.addElStyles(badge, style);
                        node.appendChild(badge);
                    }
                    /* 层叠感样式定位 */
                    if (this.batchDragStyle && this.batchDragStyle.length && this.batchDragStyle.indexOf('stack') > -1) {
                        let stack = 2;
                        if (this.batchDragData.length === 2) {
                            stack = 1;
                        }
                        for (let i = 0; i < stack; i++) {
                            const stackNode = this.dragCloneNode.cloneNode(false);
                            const stackStyle = {
                                position: 'absolute',
                                left: -5 * (i + 1) + 'px',
                                top: -5 * (i + 1) + 'px',
                                zIndex: String(-(i + 1)),
                                width: this.dragOffset.width + 'px',
                                height: this.dragOffset.height + 'px',
                                background: '#fff',
                                border: ['1px solid #5170ff', '1px solid var(--brand-1, #5170ff)']
                            };
                            Utils.addElStyles(stackNode, stackStyle);
                            node.appendChild(stackNode);
                        }
                    }
                    this.dragCloneNode = node;
                }
            }
            this.dragCloneNode.classList.add('drag-clone-node');
            if (!(this.dragPreviewDirective && this.dragPreviewDirective.dragPreviewTemplate)) {
                this.dragCloneNode.style.width = this.dragOffset.width + 'px';
                this.dragCloneNode.style.height = this.dragOffset.height + 'px';
            }
            this.dragCloneNode.style.position = 'fixed';
            this.dragCloneNode.style.zIndex = '1090';
            this.dragCloneNode.style.pointerEvents = 'none';
            this.dragCloneNode.style.top = this.dragOffset.top + 'px';
            this.dragCloneNode.style.left = this.dragOffset.left + 'px';
            this.dragCloneNode.style.willChange = 'left, top';
            this.dragItemContainer.appendChild(this.dragCloneNode);
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    if (this.draggedEl) {
                        this.draggedEl.style.display = 'none';
                        this.dragElShowHideEvent.next(false);
                        if (this.dragOriginPlaceholder) {
                            this.dragOriginPlaceholder.style.display = 'block';
                        }
                    }
                });
            });
        }
    }
    disableDraggedCloneNodeFollowMouse() {
        if (this.dragCloneNode) {
            this.document.removeEventListener('dragover', this.followMouse4CloneNode, { capture: true });
            this.dragItemContainer.removeChild(this.dragCloneNode);
            this.draggedEl.style.display = '';
            this.dragElShowHideEvent.next(true);
        }
        if (this.dragPreviewDirective && this.dragPreviewDirective.dragPreviewTemplate) {
            this.dragPreviewDirective.destroyPreview();
        }
        this.dragCloneNode = undefined;
        this.dragItemContainer = undefined;
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
        }
    }
    interceptChildNode(parentNode, childNodeList) {
        const interceptOptions = {
            root: parentNode
        };
        this.intersectionObserver = new IntersectionObserver(this.setChildNodeHide, interceptOptions);
        [].forEach.call(childNodeList, childNode => {
            this.intersectionObserver.observe(childNode);
        });
    }
    setChildNodeHide(entries) {
        entries.forEach(element => {
            const { isIntersecting, target: childNode } = element;
            if (isIntersecting) {
                childNode.style.display = 'block';
            }
            else {
                childNode.style.display = 'none';
            }
        });
    }
    getBatchDragData(identity, order = 'draggedElFirst') {
        const result = this.batchDragData.map(dragData => dragData.dragData);
        if (typeof order === 'function') {
            result.sort(order);
        }
        else if (order === 'draggedElFirst') {
            let dragData = this.dragData;
            if (identity) {
                const realDragData = this.batchDragData.filter(dd => dd.identity === identity).pop().dragData;
                dragData = realDragData;
            }
            result.splice(result.indexOf(dragData), 1);
            result.splice(0, 0, dragData);
        }
        return result;
    }
    /** usage:
     * constructor(..., private dragDropService: DragDropService) {}
     * cleanBatchDragData() { this.dragDropService.cleanBatchDragData(); }
     */
    cleanBatchDragData() {
        const batchDragData = this.batchDragData;
        if (this.batchDragData) {
            this.batchDragData
                .filter(dragData => dragData.draggable)
                .map(dragData => dragData.draggable)
                .forEach(draggable => { draggable.batchDraggable.dragData = undefined; });
            this.batchDragData = undefined;
            this.batchDragGroup = undefined;
        }
        return batchDragData;
    }
    copyStyle(source, target) {
        ['id', 'class', 'style', 'draggable'].forEach(function (att) {
            target.removeAttribute(att);
        });
        // copy style (without transitions)
        const computedStyle = getComputedStyle(source);
        for (let i = 0; i < computedStyle.length; i++) {
            const key = computedStyle[i];
            if (key.indexOf('transition') < 0) {
                target.style[key] = computedStyle[key];
            }
        }
        target.style.pointerEvents = 'none';
        // and repeat for all children
        for (let i = 0; i < source.children.length; i++) {
            this.copyStyle(source.children[i], target.children[i]);
        }
    }
}
DragDropService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropService, deps: [{ token: i0.NgZone }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });
DragDropService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });

class PreserveNextEventEmitter extends EventEmitter {
    constructor(isAsync = false) {
        super(isAsync);
        this._isAsync = isAsync;
    }
    get schedulerFns() { return this._schedulerFns; }
    forceCallback(value, once = false) {
        if (this.schedulerFns && this.schedulerFns.size) {
            this.schedulerFns.forEach(fn => {
                fn(value);
            });
            if (once) {
                this.cleanCallbackFn();
            }
        }
    }
    cleanCallbackFn() {
        this._schedulerFns = undefined;
    }
    emit(value) { super.emit(value); }
    subscribe(generatorOrNext, error, complete) {
        let schedulerFn;
        if (generatorOrNext && typeof generatorOrNext === 'object') {
            schedulerFn = this._isAsync ? (value) => {
                setTimeout(() => generatorOrNext.next(value));
            } : (value) => { generatorOrNext.next(value); };
        }
        else {
            schedulerFn = this._isAsync ? (value) => { setTimeout(() => generatorOrNext(value)); } :
                (value) => { generatorOrNext(value); };
        }
        if (!this._schedulerFns) {
            this._schedulerFns = new Set();
        }
        this._schedulerFns.add(schedulerFn);
        return super.subscribe(generatorOrNext, error, complete);
    }
}

class DragPreviewComponent {
    constructor(el, cdr) {
        this.el = el;
        this.cdr = cdr;
        this.element = el.nativeElement;
    }
    updateTemplate() {
        this.cdr.detectChanges();
    }
}
DragPreviewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragPreviewComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
DragPreviewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.3", type: DragPreviewComponent, selector: "d-drag-preview", ngImport: i0, template: "<ng-template\n  [ngTemplateOutlet]=\"templateRef\"\n  [ngTemplateOutletContext]=\"{\n    data: data,\n    draggedEl: draggedEl,\n    dragData: dragData,\n    batchDragData: batchDragData,\n    dragSyncDOMElements: dragSyncDOMElements\n  }\"\n>\n</ng-template>\n", directives: [{ type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragPreviewComponent, decorators: [{
            type: Component,
            args: [{ selector: 'd-drag-preview', preserveWhitespaces: false, template: "<ng-template\n  [ngTemplateOutlet]=\"templateRef\"\n  [ngTemplateOutletContext]=\"{\n    data: data,\n    draggedEl: draggedEl,\n    dragData: dragData,\n    batchDragData: batchDragData,\n    dragSyncDOMElements: dragSyncDOMElements\n  }\"\n>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; } });

class DragPreviewDirective {
    constructor(componentFactoryResolver, overlayContainerRef, dragDropService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.overlayContainerRef = overlayContainerRef;
        this.dragDropService = dragDropService;
        this.dragPreviewOptions = {
            skipBatchPreview: false
        };
    }
    createPreview() {
        const finalComponentFactoryResolver = this.componentFactoryResolver;
        const previewRef = this.overlayContainerRef.createComponent(finalComponentFactoryResolver.resolveComponentFactory(DragPreviewComponent));
        this.previewRef = previewRef;
        this.updateData();
        return this.previewRef;
    }
    updateData() {
        Object.assign(this.previewRef.instance, {
            templateRef: this.dragPreviewTemplate,
            data: this.dragPreviewData,
            draggedEl: this.dragDropService.draggedEl,
            dragData: this.dragDropService.dragData,
            batchDragData: this.dragDropService.batchDragData && this.dragDropService.getBatchDragData(),
            dragSyncDOMElements: this.dragDropService.dragSyncGroupDirectives && this.getDragSyncDOMElements()
        });
        this.previewRef.instance.updateTemplate();
    }
    destroyPreview() {
        if (this.previewRef) {
            this.previewRef.hostView.destroy();
        }
    }
    getPreviewElement() {
        return this.previewRef && this.previewRef.instance.element;
    }
    getDragSyncDOMElements() {
        return this.dragDropService.dragSyncGroupDirectives.map(dir => dir.el.nativeElement);
    }
}
DragPreviewDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragPreviewDirective, deps: [{ token: i0.ComponentFactoryResolver }, { token: i1$1.OverlayContainerRef }, { token: DragDropService }], target: i0.ɵɵFactoryTarget.Directive });
DragPreviewDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: DragPreviewDirective, selector: "[dDraggable][dDragPreview]", inputs: { dragPreviewTemplate: ["dDragPreview", "dragPreviewTemplate"], dragPreviewData: "dragPreviewData", dragPreviewOptions: "dragPreviewOptions" }, exportAs: ["dDragPreview"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragPreviewDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dDraggable][dDragPreview]',
                    exportAs: 'dDragPreview'
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i1$1.OverlayContainerRef }, { type: DragDropService }]; }, propDecorators: { dragPreviewTemplate: [{
                type: Input,
                args: ['dDragPreview']
            }], dragPreviewData: [{
                type: Input
            }], dragPreviewOptions: [{
                type: Input
            }] } });

/**
 * Makes an element draggable by adding the draggable html attribute
 */
class DraggableDirective {
    constructor(el, renderer, dragDropService, ngZone, dragPreviewDirective, doc) {
        this.el = el;
        this.renderer = renderer;
        this.dragDropService = dragDropService;
        this.ngZone = ngZone;
        this.dragPreviewDirective = dragPreviewDirective;
        this.doc = doc;
        this.draggable = true;
        /**
         * Currently not used
         */
        this.dragEffect = 'move';
        /**
         * Defines compatible drag drop pairs. Values must match both in draggable and droppable.dropScope.
         */
        this.dragScope = 'default';
        this.dragHandleClass = 'drag-handle';
        /**
         * Event fired when Drag is started
         */
        this.dragStartEvent = new EventEmitter();
        /**
         * @deprecated
         * Event fired while the element is being dragged
         * 为了性能优化，该函数废弃，请用(drag)自行监听， 如果不需要angular脏检测则最好用runOutsideAngular的addEventListener监听以获得好的性能
         */
        this.dragEvent = new PreserveNextEventEmitter();
        /**
         * Event fired when dragged ends
         */
        this.dragEndEvent = new EventEmitter();
        this.dropEndEvent = new PreserveNextEventEmitter();
        this.enableDragFollow = false; // 默认false使用浏览器H5API拖拽, 否则使用原dom定位偏移
        this.dragItemParentName = ''; // 当前拖拽元素的类名或元素名称（类名需要加.）,主要用于子节点的截取操作
        this.dragItemChildrenName = ''; // 当前拖拽元素的子节点类名或元素名称（类名需要加.）
        this.dragsSub = new Subscription();
        this.destroyDragEndSub = new Subscription();
        this.dragElShowHideEvent = new Subject();
        this.beforeDragStartEvent = new Subject();
        this.insertOriginPlaceholder = (directShow = true, updateService = true) => {
            if (this.delayRemoveOriginPlaceholderTimer) {
                clearTimeout(this.delayRemoveOriginPlaceholderTimer);
                this.delayRemoveOriginPlaceholderTimer = undefined;
            }
            const node = this.document.createElement(this.originPlaceholder.tag || 'div');
            const rect = this.el.nativeElement.getBoundingClientRect();
            if (directShow) {
                node.style.display = 'block';
            }
            else {
                node.style.display = 'none';
            }
            node.style.width = rect.width + 'px';
            node.style.height = rect.height + 'px';
            node.classList.add('drag-origin-placeholder');
            if (this.originPlaceholder.text) {
                node.innerText = this.originPlaceholder.text;
            }
            if (this.originPlaceholder.style) {
                Utils.addElStyles(node, this.originPlaceholder.style);
            }
            if (updateService) {
                this.dragDropService.dragOriginPlaceholder = node;
                this.dragDropService.dragOriginPlaceholderNextSibling = this.el.nativeElement.nextSibling;
            }
            else {
                node.classList.add('side-drag-origin-placeholder');
                const originCloneNode = this.el.nativeElement.cloneNode(true);
                originCloneNode.style.margin = 0;
                originCloneNode.style.pointerEvents = 'none';
                originCloneNode.style.opacity = '0.3';
                node.appendChild(originCloneNode);
            }
            this.dragOriginPlaceholder = node;
            this.dragOriginPlaceholderNextSibling = this.el.nativeElement.nextSibling;
            this.el.nativeElement.parentElement.insertBefore(node, this.el.nativeElement.nextSibling);
        };
        this.removeOriginPlaceholder = (updateService = true) => {
            if (this.dragOriginPlaceholder) {
                this.dragOriginPlaceholder.parentElement.removeChild(this.dragOriginPlaceholder);
            }
            if (updateService) {
                this.dragDropService.dragOriginPlaceholder = undefined;
                this.dragDropService.dragOriginPlaceholderNextSibling = undefined;
            }
            this.dragOriginPlaceholder = undefined;
            this.dragOriginPlaceholderNextSibling = undefined;
        };
        this.delayRemoveOriginPlaceholder = (updateService = true) => {
            const timeout = this.originPlaceholder.removeDelay;
            const delayOriginPlaceholder = this.dragOriginPlaceholder;
            const dragOriginPlaceholderNextSibling = this.findNextSibling(this.dragOriginPlaceholderNextSibling);
            // 需要临时移动位置，保证被ngFor刷新之后位置是正确的
            // ngFor刷新的原理是有变化的部分都刷新，夹在变化部分中间的内容将被刷到变化部分之后的位置，所以需要恢复位置
            // setTimeout是等ngFor的View刷新, 后续需要订阅sortContainer的view的更新才需要重新恢复位置
            if (delayOriginPlaceholder.parentElement.contains(dragOriginPlaceholderNextSibling)) {
                delayOriginPlaceholder.parentElement.insertBefore(delayOriginPlaceholder, dragOriginPlaceholderNextSibling);
            }
            setTimeout(() => {
                if (delayOriginPlaceholder.parentElement.contains(dragOriginPlaceholderNextSibling)) {
                    delayOriginPlaceholder.parentElement.insertBefore(delayOriginPlaceholder, dragOriginPlaceholderNextSibling);
                }
                delayOriginPlaceholder.classList.add('delay-deletion');
                this.delayRemoveOriginPlaceholderTimer = setTimeout(() => {
                    delayOriginPlaceholder.parentElement.removeChild(delayOriginPlaceholder);
                    if (this.document.body.contains(this.el.nativeElement)) {
                        this.el.nativeElement.style.display = '';
                        this.dragDropService.dragElShowHideEvent.next(false);
                    }
                }, timeout);
                if (updateService) {
                    this.dragDropService.dragOriginPlaceholder = undefined;
                    this.dragDropService.dragOriginPlaceholderNextSibling = undefined;
                }
                this.dragOriginPlaceholder = undefined;
                this.dragOriginPlaceholderNextSibling = undefined;
            });
        };
        this.document = this.doc;
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
        this.draggable = !this._disabled;
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            this.dragsSub.add(fromEvent(this.el.nativeElement, 'mouseover').subscribe(event => this.mouseover(event)));
            this.dragsSub.add(fromEvent(this.el.nativeElement, 'dragstart').subscribe(event => this.dragStart(event)));
            this.dragsSub.add(fromEvent(this.el.nativeElement, 'dragend').subscribe(event => this.dragEnd(event)));
        });
    }
    dropSubscription() {
        this.dragDropService.newSubscription().add(this.dragDropService.dropEvent.subscribe((event) => {
            this.mouseOverElement = undefined;
            this.renderer.removeClass(this.el.nativeElement, this.dragOverClass);
            this.dropEndEvent.emit(event);
            // 兼容虚拟滚动后被销毁
            if (this.isDestroyed) {
                if (this.dropEndEvent.schedulerFns && this.dropEndEvent.schedulerFns.size > 0) {
                    this.dropEndEvent.forceCallback(event, true);
                }
            }
            if (this.dragDropService.dragOriginPlaceholder) {
                if (this.originPlaceholder && this.originPlaceholder.removeDelay > 0
                    && !this.dragDropService.dropOnOrigin) { // 非drop到自己的情况
                    this.delayRemoveOriginPlaceholder();
                }
                else {
                    this.removeOriginPlaceholder();
                }
                this.dragDropService.draggedElIdentity = undefined;
            }
            this.dragDropService.subscription.unsubscribe();
        })).add(this.dragDropService.dragElShowHideEvent.subscribe(this.dragElShowHideEvent));
    }
    ngAfterViewInit() {
        this.applyDragHandleClass();
        if (this.dragIdentity) {
            if (this.dragDropService.draggedEl && this.dragIdentity === this.dragDropService.draggedElIdentity) {
                if (this.originPlaceholder && this.originPlaceholder.show !== false) {
                    this.insertOriginPlaceholder();
                }
                this.dragDropService.draggedEl = this.el.nativeElement;
                this.el.nativeElement.style.display = 'none'; // recovery don't need to emit event
            }
        }
    }
    ngOnDestroy() {
        // 兼容虚拟滚动后被销毁
        this.isDestroyed = true;
        if (this.dragDropService.draggedEl === this.el.nativeElement) {
            this.destroyDragEndSub = new Subscription();
            this.destroyDragEndSub.add(fromEvent(this.el.nativeElement, 'dragend').subscribe(event => {
                this.dragEnd(event);
                if (this.dropEndEvent.schedulerFns && this.dropEndEvent.schedulerFns.size > 0) {
                    this.dropEndEvent.forceCallback(event, true);
                }
                this.destroyDragEndSub.unsubscribe();
                this.destroyDragEndSub = undefined;
            }));
            if (this.originPlaceholder && this.originPlaceholder.show !== false
                && this.dragDropService.dragOriginPlaceholder && this.dragDropService.draggedElIdentity) {
                // 如果有originPlaceholder 则销毁
                this.removeOriginPlaceholder();
            }
        }
        this.dragsSub.unsubscribe();
    }
    dragStart(e) {
        if (this.allowDrag(e)) {
            this.renderer.addClass(this.el.nativeElement, this.dragOverClass);
            this.dragDropService.dragData = this.dragData;
            this.dragDropService.scope = this.dragScope;
            this.dragDropService.draggedEl = this.el.nativeElement;
            this.dragDropService.draggedElIdentity = this.dragIdentity;
            this.dragDropService.dragFollow = this.enableDragFollow;
            this.dragDropService.dragFollowOptions = this.dragFollowOptions;
            this.dragDropService.dragItemParentName = this.dragItemParentName;
            this.dragDropService.dragItemChildrenName = this.dragItemChildrenName;
            this.beforeDragStartEvent.next();
            if (this.dragPreviewDirective && this.dragPreviewDirective.dragPreviewTemplate) {
                this.dragDropService.dragFollow = true;
                this.dragDropService.dragPreviewDirective = this.dragPreviewDirective;
            }
            if (this.batchDraggable) {
                if (this.batchDraggable.dragData) {
                    // 有dragData证明被加入到了group里
                    if (this.dragDropService.batchDragData && this.dragDropService.batchDragData.length > 1) {
                        this.dragDropService.batchDragging = true;
                        this.dragDropService.batchDragStyle = this.batchDraggable.batchDragStyle;
                    }
                }
                else if (this.batchDraggable.batchDragLastOneAutoActiveEventKeys) {
                    const batchActiveAble = this.batchDraggable.batchDragLastOneAutoActiveEventKeys
                        .map(key => e[key])
                        .some(eventKey => eventKey === true);
                    if (batchActiveAble) {
                        if (this.dragDropService.batchDragData && this.dragDropService.batchDragData.length > 0) {
                            this.batchDraggable.active();
                            if (!this.batchDraggable.dragData) {
                                // 如果用户没做任何处理把项目加到组里则加到组里
                                this.batchDraggable.addToBatchGroup();
                            }
                            if (this.dragDropService.batchDragData.some(dragData => dragData.draggable === this)) {
                                this.dragDropService.batchDragging = true;
                                this.dragDropService.batchDragStyle = this.batchDraggable.batchDragStyle;
                            }
                        }
                    }
                }
            }
            const targetOffset = this.el.nativeElement.getBoundingClientRect();
            if (this.dragDropService.dragFollow) {
                const mousePositionXY = this.mousePosition(e);
                // 用于出现transform的场景position:fixed相对位置变更
                const transformOffset = this.checkAndGetViewPointChange(this.el.nativeElement);
                this.dragDropService.dragOffset = {
                    left: targetOffset.left,
                    top: targetOffset.top,
                    offsetLeft: mousePositionXY.x - targetOffset.left + transformOffset.offsetX,
                    offsetTop: mousePositionXY.y - targetOffset.top + transformOffset.offsetY,
                    width: targetOffset.width,
                    height: targetOffset.height
                };
                this.dragDropService.enableDraggedCloneNodeFollowMouse();
            }
            else {
                this.dragDropService.dragOffset = {
                    left: targetOffset.left,
                    top: targetOffset.top,
                    offsetLeft: null,
                    offsetTop: null,
                    width: targetOffset.width,
                    height: targetOffset.height
                };
            }
            if (this.originPlaceholder && this.originPlaceholder.show !== false) {
                this.insertOriginPlaceholder(false);
            }
            if (this.dragDropService.batchDragging
                && this.dragDropService.batchDragData && this.dragDropService.batchDragData.length > 1) {
                this.dragDropService.batchDragData.map(dragData => dragData.draggable)
                    .filter(draggable => draggable && draggable !== this)
                    .forEach((draggable) => {
                    if (draggable.originPlaceholder && draggable.originPlaceholder.show !== false) {
                        draggable.insertOriginPlaceholder(true, false);
                        draggable.el.nativeElement.style.display = 'none';
                    }
                    else {
                        setTimeout(() => { draggable.el.nativeElement.style.display = 'none'; });
                    }
                });
            }
            // Firefox requires setData() to be called otherwise the drag does not work.
            if (e.dataTransfer !== null) {
                e.dataTransfer.setData('text', '');
            }
            e.dataTransfer.effectAllowed = this.dragEffect;
            this.dropSubscription();
            if (this.dragDropService.dragFollow) {
                if (typeof DataTransfer.prototype.setDragImage === 'function') {
                    e.dataTransfer.setDragImage(this.dragDropService.dragEmptyImage, 0, 0);
                }
                else {
                    e.srcElement.style.display = 'none';
                    this.dragDropService.dragElShowHideEvent.next(false);
                }
            }
            e.stopPropagation();
            this.dragStartEvent.emit(e);
            this.dragDropService.dragStartEvent.next(e);
        }
        else {
            e.preventDefault();
        }
    }
    dragEnd(e) {
        this.renderer.removeClass(this.el.nativeElement, this.dragOverClass);
        this.dragDropService.dragEndEvent.next(e);
        this.mouseOverElement = undefined;
        if (this.dragDropService.draggedEl) {
            // 当dom被清除的的时候不会触发dragend，所以清理工作部分交给了drop，但是内部排序的时候dom不会被清理，dragend防止和drop重复操作清理动作
            if (this.dragDropService.dragFollow) {
                this.dragDropService.disableDraggedCloneNodeFollowMouse();
            }
            if (this.dragDropService.dragOriginPlaceholder) {
                this.removeOriginPlaceholder();
            }
            if (this.dragDropService.batchDragging && this.dragDropService.batchDragData && this.dragDropService.batchDragData.length > 1) {
                this.dragDropService.batchDragData.map(dragData => dragData.draggable)
                    .filter(draggable => draggable && draggable !== this)
                    .forEach((draggable) => {
                    if (draggable.originPlaceholder && draggable.originPlaceholder.show !== false) {
                        draggable.el.nativeElement.style.display = '';
                        draggable.removeOriginPlaceholder();
                    }
                    else {
                        draggable.el.nativeElement.style.display = '';
                    }
                });
            }
            if (this.batchDraggable && !this.batchDraggable.batchDragActive) {
                this.batchDraggable.removeFromBatchGroup();
                this.dragDropService.batchDragging = false;
                this.dragDropService.batchDragStyle = undefined;
            }
            if (this.dragDropService.subscription) {
                this.dragDropService.subscription.unsubscribe();
            }
            this.dragDropService.dragData = undefined;
            this.dragDropService.scope = undefined;
            this.dragDropService.draggedEl = undefined;
            this.dragDropService.dragFollow = undefined;
            this.dragDropService.dragFollowOptions = undefined;
            this.dragDropService.dragOffset = undefined;
            this.dragDropService.draggedElIdentity = undefined;
            this.dragDropService.dragPreviewDirective = undefined;
        }
        e.stopPropagation();
        e.preventDefault();
        this.dragEndEvent.emit(e);
    }
    mouseover(e) {
        this.mouseOverElement = e.target;
    }
    allowDrag(e) {
        if (!this.draggable) {
            return false;
        }
        if (this.batchDraggable && !this.batchDraggable.allowAddToBatchGroup()) { // 批量拖拽判断group是否相同
            return false;
        }
        if (this.dragHandle) {
            if (e && e.fromTouch) {
                return true;
            } // from touchstart dispatch event
            if (!this.mouseOverElement) {
                return false;
            }
            return Utils.matches(this.mouseOverElement, this.dragHandle);
        }
        else {
            return true;
        }
    }
    applyDragHandleClass() {
        const dragElement = this.getDragHandleElement();
        if (!dragElement) {
            return;
        }
        if (this.draggable) {
            Utils.addClass(dragElement, this.dragHandleClass);
        }
        else {
            Utils.removeClass(this.el, this.dragHandleClass);
        }
    }
    getDragHandleElement() {
        let dragElement = this.el;
        if (this.dragHandle) {
            dragElement = this.el.nativeElement.querySelector(this.dragHandle);
        }
        return dragElement;
    }
    mousePosition(event) {
        return {
            x: event.clientX,
            y: event.clientY
        };
    }
    findNextSibling(currentNextSibling) {
        if (!this.dragDropService.batchDragData) {
            return currentNextSibling;
        }
        else {
            if (this.dragDropService.batchDragData
                .map(dragData => dragData.draggable && dragData.draggable.el.nativeElement)
                .indexOf(currentNextSibling) > -1) {
                currentNextSibling = currentNextSibling.nextSibling;
            }
            return currentNextSibling;
        }
    }
    checkAndGetViewPointChange(element) {
        if (!element.parentNode) {
            return null;
        }
        // 模拟一个元素测预测位置和最终位置是否符合，如果不符合则是有transform等造成的偏移
        const elementPosition = element.getBoundingClientRect();
        const testEl = this.document.createElement('div');
        Utils.addElStyles(testEl, {
            opacity: '0',
            position: 'fixed',
            top: elementPosition.top + 'px',
            left: elementPosition.left + 'px',
            width: '1px',
            height: '1px',
            zIndex: '-999999',
        });
        element.parentNode.appendChild(testEl);
        const testElPosition = testEl.getBoundingClientRect();
        element.parentNode.removeChild(testEl);
        return {
            offsetX: testElPosition.left - elementPosition.left,
            offsetY: testElPosition.top - elementPosition.top
        };
    }
}
DraggableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DraggableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: DragDropService }, { token: i0.NgZone }, { token: DragPreviewDirective, optional: true, self: true }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });
DraggableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: DraggableDirective, selector: "[dDraggable]", inputs: { dragData: "dragData", dragHandle: "dragHandle", dragEffect: "dragEffect", dragScope: "dragScope", dragHandleClass: "dragHandleClass", dragOverClass: "dragOverClass", disabled: "disabled", enableDragFollow: "enableDragFollow", dragFollowOptions: "dragFollowOptions", originPlaceholder: "originPlaceholder", dragIdentity: "dragIdentity", dragItemParentName: "dragItemParentName", dragItemChildrenName: "dragItemChildrenName" }, outputs: { dragStartEvent: "dragStartEvent", dragEvent: "dragEvent", dragEndEvent: "dragEndEvent", dropEndEvent: "dropEndEvent" }, host: { properties: { "draggable": "this.draggable", "attr.data-drag-handle-selector": "this.dragHandle" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DraggableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dDraggable]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DragDropService }, { type: i0.NgZone }, { type: DragPreviewDirective, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { draggable: [{
                type: HostBinding,
                args: ['draggable']
            }], dragData: [{
                type: Input
            }], dragHandle: [{
                type: HostBinding,
                args: ['attr.data-drag-handle-selector']
            }, {
                type: Input
            }], dragEffect: [{
                type: Input
            }], dragScope: [{
                type: Input
            }], dragHandleClass: [{
                type: Input
            }], dragOverClass: [{
                type: Input
            }], dragStartEvent: [{
                type: Output
            }], dragEvent: [{
                type: Output
            }], dragEndEvent: [{
                type: Output
            }], dropEndEvent: [{
                type: Output
            }], disabled: [{
                type: Input
            }], enableDragFollow: [{
                type: Input
            }], dragFollowOptions: [{
                type: Input
            }], originPlaceholder: [{
                type: Input
            }], dragIdentity: [{
                type: Input
            }], dragItemParentName: [{
                type: Input
            }], dragItemChildrenName: [{
                type: Input
            }] } });

class BatchDraggableDirective {
    constructor(draggable, dragDropService) {
        this.draggable = draggable;
        this.dragDropService = dragDropService;
        this.batchDragGroup = 'default';
        this.batchDragActive = false;
        this.batchDragLastOneAutoActiveEventKeys = ['ctrlKey'];
        this.batchDragActiveEvent = new EventEmitter();
        this.needToRestore = false;
        this.batchDragStyle = ['badge', 'stack'];
        this.draggable.batchDraggable = this;
    }
    ngOnInit() {
        this.initDragDataByIdentity();
    }
    ngOnDestroy() {
        this.draggable.batchDraggable = undefined;
        if (this.dragData) {
            if (this.dragData.draggable === this.draggable) {
                this.dragData.draggable = undefined;
                if (!this.dragData.identity) {
                    this.removeFromBatchGroup();
                }
            }
        }
    }
    ngOnChanges(changes) {
        if (changes['batchDragActive']) {
            if (!this.initDragDataByIdentity()) {
                if (this.batchDragActive) {
                    if (!this.dragData && this.allowAddToBatchGroup()) {
                        this.addToBatchGroup();
                    }
                }
                else {
                    this.removeFromBatchGroup();
                }
            }
        }
    }
    ngAfterViewInit() {
        if (this.needToRestore) {
            this.restoreDragDataViewAfterViewInit();
            this.needToRestore = false;
        }
    }
    initDragDataByIdentity() {
        const dragData = this.findInBatchDragDataByIdentities();
        if (dragData) {
            if (this.batchDragActive) {
                if (!this.dragData) {
                    this.addToBatchGroup(dragData);
                    this.registerRestoreDragDataViewAfterViewInitWhiteDragging();
                }
            }
            else {
                this.removeFromBatchGroup(dragData);
            }
        }
        return dragData;
    }
    registerRestoreDragDataViewAfterViewInitWhiteDragging() {
        if (this.dragDropService.draggedEl && this.dragDropService.draggedElIdentity &&
            this.dragDropService.draggedEl !== this.draggable.el.nativeElement) {
            this.needToRestore = true;
        }
    }
    restoreDragDataViewAfterViewInit() {
        const draggable = this.draggable;
        if (draggable.originPlaceholder && draggable.originPlaceholder.show !== false) {
            draggable.insertOriginPlaceholder(true, false);
        }
        draggable.el.nativeElement.style.display = 'none';
    }
    allowAddToBatchGroup() {
        if (!this.dragDropService.batchDragGroup) {
            return true;
        }
        else {
            return this.batchDragGroup === this.dragDropService.batchDragGroup;
        }
    }
    addToBatchGroup(dragData) {
        this.dragDropService.batchDragGroup = this.dragDropService.batchDragGroup || this.batchDragGroup;
        if (dragData) {
            dragData.draggable = this.draggable;
            dragData.dragData = this.draggable.dragData;
            this.dragData = dragData;
        }
        else {
            this.dragData = this.dragData || {
                identity: this.draggable.dragIdentity || undefined,
                draggable: this.draggable,
                dragData: this.draggable.dragData
            };
            this.dragDropService.batchDragData = this.addToArrayIfNotExist(this.dragDropService.batchDragData, this.dragData);
        }
    }
    removeFromBatchGroup(dragData) {
        this.deleteFromArrayIfExist(this.dragDropService.batchDragData, dragData || this.dragData);
        this.dragData = undefined;
        if (!(this.dragDropService.batchDragData && this.dragDropService.batchDragData.length)) {
            this.dragDropService.batchDragGroup = undefined;
        }
    }
    addToArrayIfNotExist(array, target) {
        array = array || [];
        if (array.indexOf(target) === -1) {
            array.push(target);
        }
        return array;
    }
    deleteFromArrayIfExist(array, target) {
        if (!array) {
            return;
        }
        if (array.length > 0) {
            const index = array.indexOf(target);
            if (index > -1) {
                array.splice(index, 1);
            }
        }
        return array;
    }
    findInBatchDragDataByIdentities() {
        if (!this.draggable.dragIdentity) {
            return null;
        }
        else if (!this.dragDropService.batchDragData) {
            return undefined;
        }
        else {
            return this.dragDropService.batchDragData.filter(dragData => dragData.identity === this.draggable.dragIdentity).pop();
        }
    }
    active() {
        this.batchDragActiveEvent.emit({ el: this.draggable.el.nativeElement, data: this.draggable.dragData });
    }
    updateDragData() {
        // 选中状态才更新
        if (!this.dragData) {
            return;
        }
        // 需要维持内存地址不变
        Object.assign(this.dragData, {
            identity: this.draggable.dragIdentity || undefined,
            draggable: this.draggable,
            dragData: this.draggable.dragData
        });
    }
}
BatchDraggableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: BatchDraggableDirective, deps: [{ token: DraggableDirective, self: true }, { token: DragDropService }], target: i0.ɵɵFactoryTarget.Directive });
BatchDraggableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: BatchDraggableDirective, selector: "[dDraggable][batchDrag]", inputs: { batchDragGroup: "batchDragGroup", batchDragActive: "batchDragActive", batchDragLastOneAutoActiveEventKeys: "batchDragLastOneAutoActiveEventKeys", batchDragStyle: "batchDragStyle" }, outputs: { batchDragActiveEvent: "batchDragActiveEvent" }, exportAs: ["dBatchDraggable"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: BatchDraggableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dDraggable][batchDrag]',
                    exportAs: 'dBatchDraggable'
                }]
        }], ctorParameters: function () { return [{ type: DraggableDirective, decorators: [{
                    type: Self
                }] }, { type: DragDropService }]; }, propDecorators: { batchDragGroup: [{
                type: Input
            }], batchDragActive: [{
                type: Input
            }], batchDragLastOneAutoActiveEventKeys: [{
                type: Input
            }], batchDragActiveEvent: [{
                type: Output
            }], batchDragStyle: [{
                type: Input
            }] } });

class DragPreviewCloneDomRefComponent {
    constructor(el, cdr, dragDropService) {
        this.el = el;
        this.cdr = cdr;
        this.dragDropService = dragDropService;
        this.copyStyle = true;
    }
    ngAfterViewInit() {
        if (!this.cloneNode) {
            this.createView();
        }
    }
    ngOnChanges(changes) {
        if (changes['domRef']) {
            if (this.cloneNode) {
                this.destroyView();
                this.createView();
            }
            else {
                this.createView();
            }
        }
    }
    ngOnDestroy() {
        if (this.cloneNode) {
            this.destroyView();
        }
    }
    createView() {
        if (this.domRef) {
            this.cloneNode = this.domRef.cloneNode(true);
            if (this.copyStyle) {
                this.dragDropService.copyStyle(this.domRef, this.cloneNode);
            }
            this.el.nativeElement.appendChild(this.cloneNode);
        }
    }
    destroyView() {
        if (this.cloneNode) {
            if (this.el.nativeElement.contains(this.cloneNode)) {
                this.el.nativeElement.removeChild(this.cloneNode);
            }
            this.cloneNode = undefined;
        }
    }
    updateTemplate() {
        this.cdr.detectChanges();
    }
}
DragPreviewCloneDomRefComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragPreviewCloneDomRefComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: DragDropService }], target: i0.ɵɵFactoryTarget.Component });
DragPreviewCloneDomRefComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.3", type: DragPreviewCloneDomRefComponent, selector: "d-drag-preview-clone-dom-ref", inputs: { domRef: "domRef", copyStyle: "copyStyle" }, usesOnChanges: true, ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragPreviewCloneDomRefComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'd-drag-preview-clone-dom-ref',
                    template: '',
                    preserveWhitespaces: false,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: DragDropService }]; }, propDecorators: { domRef: [{
                type: Input
            }], copyStyle: [{
                type: Input
            }] } });

class DescendantRegisterService {
    constructor() {
        this._result = [];
        this.changeSubject = new BehaviorSubject([]);
        this.changes = this.changeSubject.asObservable().pipe(debounceTime(200));
    }
    register(t) {
        if (!t) {
            return;
        }
        const index = this._result.indexOf(t);
        if (index === -1) {
            this._result.push(t);
            this.changeSubject.next(this._result);
        }
    }
    unregister(t) {
        if (!t) {
            return;
        }
        const index = this._result.indexOf(t);
        if (index > -1) {
            this._result.splice(index, 1);
            this.changeSubject.next(this._result);
        }
    }
    queryResult() {
        return this._result.concat([]);
    }
}
DescendantRegisterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DescendantRegisterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DescendantRegisterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DescendantRegisterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DescendantRegisterService, decorators: [{
            type: Injectable
        }] });
/* eslint-disable-next-line @angular-eslint/directive-class-suffix */
class DescendantChildren {
    constructor(drs) {
        this.drs = drs;
    }
    ngOnInit() {
        this.drs.register(this.descendantItem);
    }
    ngOnDestroy() {
        this.drs.unregister(this.descendantItem);
    }
}
DescendantChildren.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DescendantChildren, deps: [{ token: DescendantRegisterService }], target: i0.ɵɵFactoryTarget.Directive });
DescendantChildren.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: DescendantChildren, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DescendantChildren, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: DescendantRegisterService }]; } });
class DescendantRoot extends QueryList {
    constructor(drs) {
        super();
        this.drs = drs;
    }
    on() {
        if (this.sub) {
            return;
        }
        this.reset(this.drs.queryResult());
        this.sub = this.drs.changes.subscribe(result => { this.reset(result); });
    }
    off() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
}

class DragSyncDescendantRegisterService extends DescendantRegisterService {
}
DragSyncDescendantRegisterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragSyncDescendantRegisterService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
DragSyncDescendantRegisterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragSyncDescendantRegisterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragSyncDescendantRegisterService, decorators: [{
            type: Injectable
        }] });
class DropSortSyncDescendantRegisterService extends DescendantRegisterService {
}
DropSortSyncDescendantRegisterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DropSortSyncDescendantRegisterService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
DropSortSyncDescendantRegisterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DropSortSyncDescendantRegisterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DropSortSyncDescendantRegisterService, decorators: [{
            type: Injectable
        }] });

class DragDropSyncService {
    updateDragSyncList(list) {
        this.dragSyncList = list;
    }
    getDragSyncByGroup(groupName) {
        if (groupName === '') {
            return [];
        }
        return this.dragSyncList ? this.dragSyncList.filter(dragSync => dragSync.dragSyncGroup === groupName) : [];
    }
    updateDropSyncList(list) {
        this.dropSortSyncList = list;
    }
    getDropSyncByGroup(groupName) {
        if (groupName === '') {
            return [];
        }
        return this.dropSortSyncList ? this.dropSortSyncList.filter(dropSync => dropSync.dropSyncGroup === groupName) : [];
    }
}
DragDropSyncService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropSyncService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DragDropSyncService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropSyncService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropSyncService, decorators: [{
            type: Injectable
        }] });

class DragSyncDirective extends DescendantChildren {
    constructor(el, draggable, dragDropSyncService, dragDropService, dragSyncDrs) {
        super(dragSyncDrs);
        this.el = el;
        this.draggable = draggable;
        this.dragDropSyncService = dragDropSyncService;
        this.dragDropService = dragDropService;
        this.dragSyncDrs = dragSyncDrs;
        this.dragSyncGroup = '';
        this.subscription = new Subscription();
        this.subDragElEvent = (bool) => {
            this.syncGroupDirectives.forEach(dir => this.renderDisplay(dir.el.nativeElement, bool));
        };
        this.descendantItem = this;
    }
    ngOnInit() {
        if (this.draggable) {
            this.subscription.add(this.draggable.dragElShowHideEvent.subscribe(this.subDragElEvent));
            this.subscription.add(this.draggable.beforeDragStartEvent.subscribe(() => {
                this.syncGroupDirectives = this.dragDropSyncService.getDragSyncByGroup(this.dragSyncGroup).filter(directive => directive !== this);
                this.dragDropService.dragSyncGroupDirectives = this.syncGroupDirectives;
            }));
            this.subscription.add(this.draggable.dropEndEvent.subscribe(() => {
                this.dragDropService.dragSyncGroupDirectives = undefined;
                this.syncGroupDirectives = undefined;
            }));
        }
        super.ngOnInit();
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    renderDisplay(nativeEl, bool) {
        nativeEl.style.display = bool ? '' : 'none';
    }
}
DragSyncDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragSyncDirective, deps: [{ token: i0.ElementRef }, { token: DraggableDirective, optional: true, self: true }, { token: DragDropSyncService }, { token: DragDropService }, { token: DragSyncDescendantRegisterService }], target: i0.ɵɵFactoryTarget.Directive });
DragSyncDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: DragSyncDirective, selector: "[dDragSync]", inputs: { dragSyncGroup: ["dDragSync", "dragSyncGroup"] }, exportAs: ["dDragSync"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragSyncDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dDragSync]',
                    exportAs: 'dDragSync'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: DraggableDirective, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: DragDropSyncService }, { type: DragDropService }, { type: DragSyncDescendantRegisterService }]; }, propDecorators: { dragSyncGroup: [{
                type: Input,
                args: ['dDragSync']
            }] } });

class DragDropSyncBoxDirective {
    constructor(dragDropSyncService, dragSyncDrs, dropSortSyncDrs) {
        this.dragDropSyncService = dragDropSyncService;
        this.dragSyncDrs = dragSyncDrs;
        this.dropSortSyncDrs = dropSortSyncDrs;
        this.sub = new Subscription();
    }
    ngOnInit() {
        this.dragSyncList = new DescendantRoot(this.dragSyncDrs);
        this.dropSyncList = new DescendantRoot(this.dropSortSyncDrs);
    }
    ngAfterViewInit() {
        this.dragSyncList.on();
        this.dropSyncList.on();
        this.dragDropSyncService.updateDragSyncList(this.dragSyncList);
        this.dragDropSyncService.updateDropSyncList(this.dropSyncList);
        this.sub.add(this.dragSyncList.changes.subscribe(list => this.dragDropSyncService.updateDragSyncList(list))).add(this.dropSyncList.changes.subscribe(list => this.dragDropSyncService.updateDropSyncList(list)));
    }
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
        this.dragSyncList.off();
        this.dropSyncList.off();
    }
}
DragDropSyncBoxDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropSyncBoxDirective, deps: [{ token: DragDropSyncService }, { token: DragSyncDescendantRegisterService }, { token: DropSortSyncDescendantRegisterService }], target: i0.ɵɵFactoryTarget.Directive });
DragDropSyncBoxDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: DragDropSyncBoxDirective, selector: "[dDragDropSyncBox]", providers: [
        DragDropSyncService,
        DragSyncDescendantRegisterService,
        DropSortSyncDescendantRegisterService,
    ], exportAs: ["dDragDropSyncBox"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropSyncBoxDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dDragDropSyncBox]',
                    exportAs: 'dDragDropSyncBox',
                    providers: [
                        DragDropSyncService,
                        DragSyncDescendantRegisterService,
                        DropSortSyncDescendantRegisterService,
                    ]
                }]
        }], ctorParameters: function () { return [{ type: DragDropSyncService }, { type: DragSyncDescendantRegisterService }, { type: DropSortSyncDescendantRegisterService }]; } });

var DropScrollOrientation;
(function (DropScrollOrientation) {
    DropScrollOrientation[DropScrollOrientation["forward"] = 0] = "forward";
    DropScrollOrientation[DropScrollOrientation["backward"] = 1] = "backward"; // 退， 左/上
})(DropScrollOrientation || (DropScrollOrientation = {}));
const DropScrollEnhanceTimingFunctionGroup = {
    default: (x) => Math.ceil((1 - x) * 18) * 100
};

class DropScrollEnhancedDirective {
    constructor(el, zone, dragDropService, doc) {
        this.el = el;
        this.zone = zone;
        this.dragDropService = dragDropService;
        this.doc = doc;
        this.minSpeed = 50;
        this.maxSpeed = 1000;
        this.responseEdgeWidth = '100px';
        this.speedFn = DropScrollEnhanceTimingFunctionGroup.default;
        this.direction = 'v';
        this.backSpaceDroppable = true;
        this.subscription = new Subscription();
        this.document = this.doc;
    }
    ngAfterViewInit() {
        // 设置父元素
        this.el.nativeElement.parentNode.style.position = 'relative';
        this.el.nativeElement.parentNode.style.display = 'block';
        // 创建后退前进区域和对应的滚动函数
        this.forwardScrollArea = this.createScrollArea(this.direction, DropScrollOrientation.forward);
        this.backwardScrollArea = this.createScrollArea(this.direction, DropScrollOrientation.backward);
        this.forwardScrollFn = this.createScrollFn(this.direction, DropScrollOrientation.forward, this.speedFn);
        this.backwardScrollFn = this.createScrollFn(this.direction, DropScrollOrientation.backward, this.speedFn);
        this.zone.runOutsideAngular(() => {
            // 拖拽到其上触发滚动
            this.subscription.add(fromEvent(this.forwardScrollArea, 'dragover')
                .pipe(tap(event => { event.preventDefault(); event.stopPropagation(); }), throttleTime(100, undefined, { leading: true, trailing: false })).subscribe(event => this.forwardScrollFn(event)));
            this.subscription.add(fromEvent(this.backwardScrollArea, 'dragover')
                .pipe(tap(event => { event.preventDefault(); event.stopPropagation(); }), throttleTime(100, undefined, { leading: true, trailing: false }))
                .subscribe(event => this.backwardScrollFn(event)));
            // 拖拽放置委托
            this.subscription.add(merge(fromEvent(this.forwardScrollArea, 'drop'), fromEvent(this.backwardScrollArea, 'drop')).subscribe(event => this.delegateDropEvent(event)));
            // 拖拽离开清除参数
            this.subscription.add(merge(fromEvent(this.forwardScrollArea, 'dragleave', { passive: true }), fromEvent(this.backwardScrollArea, 'dragleave', { passive: true })).subscribe(event => this.cleanLastScrollTime()));
            // 滚动过程计算区域有效性，滚动条贴到边缘的时候无效，无效的时候设置鼠标事件可用为none
            this.subscription.add(fromEvent(this.el.nativeElement, 'scroll', { passive: true })
                .pipe(throttleTime(300, undefined, { leading: true, trailing: true }))
                .subscribe(event => {
                this.toggleScrollToOneEnd(this.el.nativeElement, this.forwardScrollArea, this.direction, DropScrollOrientation.forward);
                this.toggleScrollToOneEnd(this.el.nativeElement, this.backwardScrollArea, this.direction, DropScrollOrientation.backward);
            }));
            // 窗口缩放的时候重绘有效性区域
            this.subscription.add(fromEvent(window, 'resize', { passive: true })
                .pipe(throttleTime(300, undefined, { leading: true, trailing: true }))
                .subscribe(event => this.resizeArea()));
            // dragstart的时候显示拖拽滚动边缘面板
            this.subscription.add(this.dragDropService.dragStartEvent.subscribe(() => {
                if (!this.allowScroll()) {
                    return;
                }
                this.zone.runOutsideAngular(() => {
                    setTimeout(() => {
                        // 立马出现会打断边缘元素的拖拽
                        this.forwardScrollArea.style.display = 'block';
                        this.backwardScrollArea.style.display = 'block';
                    });
                });
            }));
            // dragEnd或drop的时候结束了拖拽，滚动区域影藏起来
            this.subscription.add(merge(this.dragDropService.dragEndEvent, this.dragDropService.dropEvent)
                .subscribe(() => {
                this.forwardScrollArea.style.display = 'none';
                this.backwardScrollArea.style.display = 'none';
                this.lastScrollTime = undefined;
            }));
        });
        setTimeout(() => {
            this.resizeArea();
        }, 0);
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    createScrollFn(direction, orientation, speedFn) {
        if (typeof window === 'undefined') {
            return;
        }
        const scrollAttr = (direction === 'v') ? 'scrollTop' : 'scrollLeft';
        const eventAttr = (direction === 'v') ? 'clientY' : 'clientX';
        const scrollWidthAttr = (direction === 'v') ? 'scrollHeight' : 'scrollWidth';
        const offsetWidthAttr = (direction === 'v') ? 'offsetHeight' : 'offsetWidth';
        const clientWidthAttr = (direction === 'v') ? 'clientHeight' : 'clientWidth';
        const rectWidthAttr = (direction === 'v') ? 'height' : 'width';
        const compareTarget = (orientation === DropScrollOrientation.forward) ? this.forwardScrollArea : this.backwardScrollArea;
        const targetAttr = this.getCriticalEdge(direction, orientation);
        const scrollElement = this.el.nativeElement;
        return (event) => {
            const compareTargetRect = compareTarget.getBoundingClientRect();
            const distance = event[eventAttr] - compareTargetRect[targetAttr];
            let speed = speedFn(Math.abs(distance / (compareTargetRect[rectWidthAttr] || 1)));
            if (speed < this.minSpeed) {
                speed = this.minSpeed;
            }
            if (speed > this.maxSpeed) {
                speed = this.maxSpeed;
            }
            if (distance < 0) {
                speed = -speed;
            }
            if (this.animationFrameId) {
                window.cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = undefined;
            }
            this.animationFrameId = requestAnimationFrame(() => {
                const time = new Date().getTime();
                const moveDistance = Math.ceil(speed * (time - (this.lastScrollTime || time)) / 1000);
                scrollElement[scrollAttr] -= moveDistance;
                this.lastScrollTime = time;
                // 判断是不是到尽头
                if ((scrollElement[scrollAttr] === 0 && orientation === DropScrollOrientation.backward)
                    || ((scrollElement[scrollAttr]
                        + (scrollElement.getBoundingClientRect())[rectWidthAttr]
                        - scrollElement[offsetWidthAttr]
                        + scrollElement[clientWidthAttr]) === scrollElement[scrollWidthAttr]
                        && orientation === DropScrollOrientation.forward)) {
                    compareTarget.style.pointerEvents = 'none';
                    this.toggleActiveClass(compareTarget, false);
                }
                this.animationFrameId = undefined;
            });
            if (this.backSpaceDroppable) {
                Utils.dispatchEventToUnderElement(event);
            }
        };
    }
    delegateDropEvent(event) {
        if (this.backSpaceDroppable) {
            const ev = Utils.dispatchEventToUnderElement(event);
            if (ev.defaultPrevented) {
                event.preventDefault();
                event.stopPropagation();
            }
        }
    }
    getCriticalEdge(direction, orientation) {
        return (direction === 'v' && orientation === DropScrollOrientation.forward && 'bottom')
            || (direction === 'v' && orientation === DropScrollOrientation.backward && 'top')
            || (direction !== 'v' && orientation === DropScrollOrientation.forward && 'right')
            || (direction !== 'v' && orientation === DropScrollOrientation.backward && 'left') || 'bottom';
    }
    getSecondEdge(direction) {
        return (direction === 'v' && 'left')
            || (direction !== 'v' && 'top') || 'left';
    }
    createScrollArea(direction, orientation) {
        const area = this.document.createElement('div');
        area.className = 'dropover-scroll-area ' + 'dropover-scroll-area-' + this.getCriticalEdge(direction, orientation);
        // 处理大小
        area.classList.add('active');
        this.setAreaSize(area, direction, orientation);
        // 处理位置
        area.style.position = 'absolute';
        this.setAreaStyleLayout(area, direction, orientation);
        // 默认不展示
        area.style.display = 'none';
        // 附着元素
        this.el.nativeElement.parentNode.appendChild(area, this.el.nativeElement);
        return area;
    }
    setAreaSize(area, direction, orientation) {
        const rect = this.el.nativeElement.getBoundingClientRect();
        const containerAttr = direction === 'v' ? 'height' : 'width';
        const responseEdgeWidth = (typeof this.responseEdgeWidth === 'string')
            ? this.responseEdgeWidth
            : this.responseEdgeWidth(rect[containerAttr]);
        const settingOffset = this.viewOffset
            && (orientation === DropScrollOrientation.forward ? this.viewOffset.forward : this.viewOffset.backward);
        let width = direction === 'v' ? (rect.width + 'px') : responseEdgeWidth;
        let height = direction === 'v' ? responseEdgeWidth : (rect.height + 'px');
        if (settingOffset) {
            if (settingOffset.widthOffset) {
                width = 'calc(' + width + ' + ' + (settingOffset.widthOffset) + 'px)';
            }
            if (settingOffset.heightOffset) {
                height = 'calc(' + height + ' + ' + (settingOffset.heightOffset) + 'px)';
            }
        }
        area.style.width = width;
        area.style.height = height;
    }
    setAreaStyleLayout(area, direction, orientation) {
        const target = this.el.nativeElement;
        const relatedTarget = this.el.nativeElement.parentNode;
        const defaultOffset = { left: 0, right: 0, top: 0, bottom: 0 };
        const settingOffset = this.viewOffset
            && (orientation === DropScrollOrientation.forward ? this.viewOffset.forward : this.viewOffset.backward)
            || defaultOffset;
        const criticalEdge = this.getCriticalEdge(direction, orientation);
        const secondEdge = this.getSecondEdge(direction);
        [criticalEdge, secondEdge].forEach(edge => {
            area.style[edge] = this.getRelatedPosition(target, relatedTarget, edge, settingOffset[edge]);
        });
    }
    getRelatedPosition(target, relatedTarget, edge, offsetValue) {
        if (typeof window === 'undefined') {
            return '0px';
        }
        const relatedComputedStyle = window.getComputedStyle(relatedTarget);
        const relatedRect = relatedTarget.getBoundingClientRect();
        const selfRect = target.getBoundingClientRect();
        const helper = {
            left: ['left', 'Left'],
            right: ['right', 'Right'],
            top: ['top', 'Top'],
            bottom: ['bottom', 'Bottom'],
        };
        let factor = 1;
        if (edge === 'right' || edge === 'bottom') {
            factor = -1;
        }
        return (selfRect[helper[edge][0]] - relatedRect[helper[edge][0]]
            + parseInt(relatedComputedStyle['border' + helper[edge][1] + 'Width'], 10)) * factor
            + (offsetValue || 0)
            + 'px';
    }
    resizeArea() {
        [{ area: this.forwardScrollArea, orientation: DropScrollOrientation.forward },
            { area: this.backwardScrollArea, orientation: DropScrollOrientation.backward }
        ]
            .forEach(item => {
            this.setAreaSize(item.area, this.direction, item.orientation);
            this.setAreaStyleLayout(item.area, this.direction, item.orientation);
        });
    }
    toggleScrollToOneEnd(scrollElement, toggleElement, direction, orientation) {
        const scrollAttr = (direction === 'v') ? 'scrollTop' : 'scrollLeft';
        const scrollWidthAttr = (direction === 'v') ? 'scrollHeight' : 'scrollWidth';
        const offsetWidthAttr = (direction === 'v') ? 'offsetHeight' : 'offsetWidth';
        const clientWidthAttr = (direction === 'v') ? 'clientHeight' : 'clientWidth';
        const rectWidthAttr = (direction === 'v') ? 'height' : 'width';
        if ((scrollElement[scrollAttr] === 0 && orientation === DropScrollOrientation.backward) || (Math.abs(scrollElement[scrollAttr]
            + (scrollElement.getBoundingClientRect())[rectWidthAttr]
            - scrollElement[scrollWidthAttr]
            - scrollElement[offsetWidthAttr]
            + scrollElement[clientWidthAttr]) < 1
            && orientation === DropScrollOrientation.forward)) {
            toggleElement.style.pointerEvents = 'none';
            this.toggleActiveClass(toggleElement, false);
        }
        else {
            toggleElement.style.pointerEvents = 'auto';
            this.toggleActiveClass(toggleElement, true);
        }
    }
    cleanLastScrollTime() {
        if (this.animationFrameId && typeof window !== 'undefined') {
            window.cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = undefined;
        }
        this.lastScrollTime = undefined;
    }
    toggleActiveClass(target, active) {
        if (active) {
            target.classList.remove('inactive');
            target.classList.add('active');
        }
        else {
            target.classList.remove('active');
            target.classList.add('inactive');
        }
    }
    allowScroll() {
        if (!this.dropScrollScope) {
            return true;
        }
        let allowed = false;
        if (typeof this.dropScrollScope === 'string') {
            if (typeof this.dragDropService.scope === 'string') {
                allowed = this.dragDropService.scope === this.dropScrollScope;
            }
            if (this.dragDropService.scope instanceof Array) {
                allowed = this.dragDropService.scope.indexOf(this.dropScrollScope) > -1;
            }
        }
        if (this.dropScrollScope instanceof Array) {
            if (typeof this.dragDropService.scope === 'string') {
                allowed = this.dropScrollScope.indexOf(this.dragDropService.scope) > -1;
            }
            if (this.dragDropService.scope instanceof Array) {
                allowed = this.dropScrollScope.filter((item) => {
                    return this.dragDropService.scope.indexOf(item) !== -1;
                }).length > 0;
            }
        }
        return allowed;
    }
}
DropScrollEnhancedDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DropScrollEnhancedDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: DragDropService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });
DropScrollEnhancedDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: DropScrollEnhancedDirective, selector: "[dDropScrollEnhanced]", inputs: { minSpeed: "minSpeed", maxSpeed: "maxSpeed", responseEdgeWidth: "responseEdgeWidth", speedFn: "speedFn", direction: "direction", viewOffset: "viewOffset", dropScrollScope: "dropScrollScope", backSpaceDroppable: "backSpaceDroppable" }, exportAs: ["dDropScrollEnhanced"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DropScrollEnhancedDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dDropScrollEnhanced]',
                    exportAs: 'dDropScrollEnhanced'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: DragDropService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { minSpeed: [{
                type: Input
            }], maxSpeed: [{
                type: Input
            }], responseEdgeWidth: [{
                type: Input
            }], speedFn: [{
                type: Input
            }], direction: [{
                type: Input
            }], viewOffset: [{
                type: Input
            }], dropScrollScope: [{
                type: Input
            }], backSpaceDroppable: [{
                type: Input
            }] } });

class DropScrollEnhancedSideDirective extends DropScrollEnhancedDirective {
    constructor() {
        super(...arguments);
        this.sideDirection = 'v';
    }
    ngOnInit() {
        this.direction = this.sideDirection === 'v' ? 'h' : 'v';
    }
}
DropScrollEnhancedSideDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DropScrollEnhancedSideDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
DropScrollEnhancedSideDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: DropScrollEnhancedSideDirective, selector: "[dDropScrollEnhancedSide]", inputs: { sideDirection: ["direction", "sideDirection"] }, exportAs: ["dDropScrollEnhancedSide"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DropScrollEnhancedSideDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dDropScrollEnhancedSide]',
                    exportAs: 'dDropScrollEnhancedSide'
                }]
        }], propDecorators: { sideDirection: [{
                type: Input,
                args: ['direction']
            }] } });

class DropEvent {
    constructor(event, data, dropSubject, dropIndex, dragFromIndex, dropOnItem, dropOnOrigin, batchDragData) {
        this.nativeEvent = event;
        this.dragData = data;
        this.dropSubject = dropSubject;
        this.dropIndex = dropIndex;
        this.dragFromIndex = dragFromIndex;
        this.dropOnItem = dropOnItem;
        this.dropOnOrigin = dropOnOrigin;
        this.batchDragData = batchDragData;
    }
}

class DroppableDirective {
    constructor(el, renderer, dragDropService, ngZone, doc) {
        this.el = el;
        this.renderer = renderer;
        this.dragDropService = dragDropService;
        this.ngZone = ngZone;
        this.doc = doc;
        /**
           *  Event fired when Drag dragged element enters a valid drop target.
           */
        this.dragEnterEvent = new EventEmitter();
        /**
           * Event fired when an element is being dragged over a valid drop target
           */
        this.dragOverEvent = new EventEmitter();
        /**
           * Event fired when a dragged element leaves a valid drop target.
           */
        this.dragLeaveEvent = new EventEmitter();
        /**
           * Event fired when an element is dropped on a valid drop target.
           */
        this.dropEvent = new EventEmitter(); // 注意使用了虚拟滚动后，DropEvent中的dragFromIndex无效
        /**
           * Defines compatible drag drop pairs. Values must match both in draggable and droppable.dropScope.
           */
        this.dropScope = 'default';
        this.placeholderTag = 'div';
        this.placeholderStyle = { backgroundColor: ['#859bff', `var(--devui-brand-foil, #859bff)`], opacity: '.4' };
        /**
           * 设置placeholder的提示性文字，仅支持文本（安全起见）
           */
        this.placeholderText = '';
        /**
           * 用于允许拖动到元素上，方便树形结构的拖动可以成为元素的子节点
           */
        this.allowDropOnItem = false;
        /**
          *  是否启用越过立即交换位置的算法, 不能与allowDropOnItem一起用，allowDropOnItem为true时，此规则无效
          * */
        this.switchWhileCrossEdge = false;
        /**
          *  sortable的情况下，拖动到可以drop但不在sortContainer里的时候默认drop的位置
          * */
        this.defaultDropPosition = 'closest';
        // 用于修复dragleave多次触发
        this.dragCount = 0;
        this.dropIndex = undefined;
        /* 协同拖拽需要 */
        this.placeholderInsertionEvent = new Subject();
        this.placeholderRenderEvent = new Subject();
        this.dropSortCountSelectorFilterFn = (value) => {
            return Utils.matches(value, this.dropSortCountSelector)
                || value.contains(this.placeholder)
                || value === this.dragDropService.dragOriginPlaceholder;
        };
        this.setPlaceholder = () => {
            this.ngZone.runOutsideAngular(() => {
                this.placeholder.style.width = this.dragDropService.dragOffset.width + 'px';
                this.placeholder.style.height = this.dragDropService.dragOffset.height + 'px'; // ie下clientHeight为0
                Utils.addElStyles(this.placeholder, this.placeholderStyle);
                this.placeholderRenderEvent.next({ width: this.dragDropService.dragOffset.width, height: this.dragDropService.dragOffset.height });
            });
        };
        this.document = this.doc;
    }
    ngOnInit() {
        this.placeholder = this.document.createElement(this.placeholderTag);
        this.placeholder.className = 'drag-placeholder';
        this.placeholder.innerText = this.placeholderText;
        this.dragStartSubscription = this.dragDropService.dragStartEvent.subscribe(() => this.setPlaceholder());
        if (this.dragDropService.draggedEl) {
            this.setPlaceholder(); // 虚拟滚动生成元素过程中
        }
        this.dropEndSubscription = this.dragDropService.dropEvent.subscribe(() => {
            if (this.dragDropService.draggedEl) {
                if (!this.dragDropService.dragFollow) {
                    this.renderer.setStyle(this.dragDropService.draggedEl, 'display', '');
                    this.dragDropService.dragElShowHideEvent.next(true);
                }
            }
            this.removePlaceholder();
            this.overElement = undefined;
            this.allowDropCache = undefined;
            this.dragElIndex = undefined;
            this.dropIndex = undefined;
        });
        this.dragEndSubscription = this.dragDropService.dragEndEvent.subscribe(() => {
            if (this.dragDropService.draggedEl) {
                if (!this.dragDropService.dragFollow) {
                    this.renderer.setStyle(this.dragDropService.draggedEl, 'display', '');
                    this.dragDropService.dragElShowHideEvent.next(true);
                }
            }
            this.removePlaceholder();
            this.dragCount = 0;
            this.overElement = undefined;
            this.allowDropCache = undefined;
            this.dragElIndex = undefined;
            this.dropIndex = undefined;
        });
        this.ngZone.runOutsideAngular(() => {
            this.dragPartEventSub = new Subscription();
            this.dragPartEventSub.add(fromEvent(this.el.nativeElement, 'dragover')
                .pipe(filter(event => this.allowDrop(event)), distinctUntilChanged((prev, current) => {
                const bool = (prev.clientX === current.clientX && prev.clientY === current.clientY && prev.target === current.target);
                if (bool) {
                    current.preventDefault();
                    current.stopPropagation();
                }
                return bool;
            }))
                .subscribe((event) => this.dragOver(event)));
            this.dragPartEventSub.add(fromEvent(this.el.nativeElement, 'dragenter').subscribe((event) => this.dragEnter(event)));
            this.dragPartEventSub.add(fromEvent(this.el.nativeElement, 'dragleave').subscribe((event) => this.dragLeave(event)));
        });
    }
    ngAfterViewInit() {
        if (this.el.nativeElement.hasAttribute('d-sortable')) {
            this.sortContainer = this.el.nativeElement;
        }
        else {
            this.sortContainer = this.el.nativeElement.querySelector('[d-sortable]');
        }
        this.sortDirection = this.sortContainer ? this.sortContainer.getAttribute('dsortable') || 'v' : 'v';
        this.sortDirectionZMode = this.sortContainer ? (this.sortContainer.getAttribute('d-sortable-zmode') === 'true' || false) : false;
    }
    ngOnDestroy() {
        this.dragStartSubscription.unsubscribe();
        this.dragEndSubscription.unsubscribe();
        this.dropEndSubscription.unsubscribe();
        if (this.dragPartEventSub) {
            this.dragPartEventSub.unsubscribe();
        }
    }
    dragEnter(e) {
        this.dragCount++;
        e.preventDefault(); // ie11 dragenter需要preventDefault否则dragover无效
        this.dragEnterEvent.emit(e);
    }
    dragOver(e) {
        if (this.allowDrop(e)) {
            if (this.dragDropService.dropTargets.indexOf(this.el) === -1) {
                this.dragDropService.dropTargets.forEach(el => {
                    const placeHolderEl = el.nativeElement.querySelector('.drag-placeholder');
                    if (placeHolderEl) {
                        placeHolderEl.parentElement.removeChild(placeHolderEl);
                    }
                    Utils.removeClass(el, this.dragOverClass);
                    this.removeDragoverItemClass(el.nativeElement);
                });
                this.dragDropService.dropTargets = [this.el];
                this.overElement = undefined; // 否则会遇到上一次position= 这一次的然后不刷新和插入。
            }
            Utils.addClass(this.el, this.dragOverClass);
            const hitPlaceholder = this.dragDropService.dragOriginPlaceholder && this.dragDropService.dragOriginPlaceholder.contains(e.target);
            if (this.sortContainer && ((hitPlaceholder && this.overElement === undefined)
                || !(e.target.contains(this.placeholder) || hitPlaceholder)
                || (this.switchWhileCrossEdge && !this.placeholder.contains(e.target) && !hitPlaceholder) // 越边交换回折的情况需要重新计算
                || (!this.sortContainer.contains(e.target) && this.defaultDropPosition === 'closest') // 就近模式需要重新计算
            )) {
                const overElement = this.findSortableEl(e);
                if (!(this.overElement && overElement) || this.overElement.index !== overElement.index
                    || (this.allowDropOnItem && this.overElement.position !== overElement.position
                        && (this.overElement.position === 'inside' || overElement.position === 'inside'))) {
                    // overElement的参数有刷新的时候才进行插入等操作
                    this.overElement = overElement;
                    this.insertPlaceholder(overElement);
                    this.removeDragoverItemClass(this.sortContainer, overElement);
                    if (overElement.position === 'inside' && this.dragOverItemClass) {
                        Utils.addClass(overElement.el, this.dragOverItemClass);
                    }
                }
                else {
                    this.overElement = overElement;
                }
            }
            else {
                if (this.sortContainer && this.overElement && this.overElement.el) {
                    if (!this.overElement.el.contains(e.target)) {
                        this.overElement.realEl = e.target;
                    }
                    else {
                        this.overElement.realEl = undefined;
                    }
                }
            }
            if (this.dragDropService.draggedEl) {
                if (!this.dragDropService.dragFollow) {
                    this.renderer.setStyle(this.dragDropService.draggedEl, 'display', 'none');
                    this.dragDropService.dragElShowHideEvent.next(false);
                    if (this.dragDropService.dragOriginPlaceholder) {
                        this.renderer.setStyle(this.dragDropService.dragOriginPlaceholder, 'display', 'block');
                    }
                }
            }
            e.preventDefault();
            e.stopPropagation();
            this.dragOverEvent.emit(e);
        }
    }
    dragLeave(e) {
        // 用于修复包含子元素时，多次触发dragleave
        this.dragCount--;
        if (this.dragCount === 0) {
            if (this.dragDropService.dropTargets.indexOf(this.el) !== -1) {
                this.dragDropService.dropTargets = [];
            }
            Utils.removeClass(this.el, this.dragOverClass);
            this.removePlaceholder();
            this.removeDragoverItemClass(this.el.nativeElement);
            this.overElement = undefined;
            this.dragElIndex = undefined;
            this.dropIndex = undefined;
        }
        e.preventDefault();
        this.dragLeaveEvent.emit(e);
    }
    drop(e) {
        if (!this.allowDrop(e)) {
            return;
        }
        this.dragCount = 0;
        Utils.removeClass(this.el, this.dragOverClass);
        this.removeDragoverItemClass(this.sortContainer);
        this.removePlaceholder();
        e.preventDefault();
        e.stopPropagation();
        this.dragDropService.dropOnOrigin = this.isDragPlaceholderPosition(this.dropIndex);
        const draggedElIdentity = this.dragDropService.draggedElIdentity;
        this.dragDropService.draggedElIdentity = undefined; // 需要提前清除，避免新生成的节点复用了id 刷新了dragOriginPlaceholder
        let batchDraggble = [];
        if (this.dragDropService.batchDragData && this.dragDropService.batchDragData.length > 1) {
            batchDraggble = this.dragDropService.batchDragData.map(dragData => dragData.draggable)
                .filter(draggable => draggable && draggable.el.nativeElement !== this.dragDropService.draggedEl);
        }
        this.dropEvent.emit(new DropEvent(e, this.dragDropService.dragData, this.dragDropService.dropEvent, this.dropSortVirtualScrollOption ? this.getRealIndex(this.dropIndex, this.dropFlag) : this.dropIndex, this.sortContainer ? this.checkSelfFromIndex(this.dragDropService.draggedEl) : -1, this.dragDropService.dropOnItem, this.dragDropService.dropOnOrigin, (this.dragDropService.batchDragging)
            ? this.dragDropService.getBatchDragData(draggedElIdentity)
            : undefined));
        // 如果drop之后drag元素被删除，则不会发生dragend事件，需要代替dragend清理
        if (this.dragDropService.dragFollow) {
            this.dragDropService.disableDraggedCloneNodeFollowMouse();
        }
        else {
            this.renderer.setStyle(this.dragDropService.draggedEl, 'display', '');
            this.dragDropService.dragElShowHideEvent.next(false);
        }
        if (batchDraggble.length > 0 && this.dragDropService.batchDragging) {
            batchDraggble.forEach((draggable) => {
                if (!draggable.originPlaceholder || draggable.originPlaceholder.show === false) {
                    draggable.el.nativeElement.style.display = '';
                }
                else if (draggable.originPlaceholder.removeDelay > 0 && !this.dragDropService.dropOnOrigin) {
                    draggable.delayRemoveOriginPlaceholder(false);
                }
                else {
                    draggable.el.nativeElement.style.display = '';
                    draggable.removeOriginPlaceholder(false);
                }
            });
        }
        this.dragDropService.dropEvent.next(e);
        this.dragDropService.dragData = undefined;
        this.dragDropService.scope = undefined;
        this.dragDropService.draggedEl = undefined;
        this.dragDropService.dragFollow = undefined;
        this.dragDropService.dragFollowOptions = undefined;
        this.dragDropService.dragOffset = undefined;
        this.dragDropService.dropOnOrigin = undefined;
        this.dragDropService.batchDragging = false;
        this.dragDropService.batchDragStyle = undefined;
        this.dragDropService.dragPreviewDirective = undefined;
    }
    allowDrop(e) {
        if (!e) {
            return false;
        }
        if (this.allowDropCache !== undefined) {
            return this.allowDropCache;
        }
        let allowed = false;
        if (typeof this.dropScope === 'string') {
            if (typeof this.dragDropService.scope === 'string') {
                allowed = this.dragDropService.scope === this.dropScope;
            }
            if (this.dragDropService.scope instanceof Array) {
                allowed = this.dragDropService.scope.indexOf(this.dropScope) > -1;
            }
        }
        if (this.dropScope instanceof Array) {
            if (typeof this.dragDropService.scope === 'string') {
                allowed = this.dropScope.indexOf(this.dragDropService.scope) > -1;
            }
            if (this.dragDropService.scope instanceof Array) {
                allowed = this.dropScope.filter((item) => {
                    return this.dragDropService.scope.indexOf(item) !== -1;
                }).length > 0;
            }
        }
        this.allowDropCache = allowed;
        return allowed;
    }
    // 查询需要插入placeholder的位置
    /* eslint-disable-next-line complexity*/
    findSortableEl(event) {
        const moveElement = event.target;
        let overElement = null;
        if (!this.sortContainer) {
            return overElement;
        }
        overElement = { index: 0, el: null, position: 'before' };
        this.dropIndex = 0;
        this.dropFlag = undefined;
        let childEls = Utils.slice(this.sortContainer.children);
        // 删除虚拟滚动等的额外元素不需要计算的元素
        if (this.dropSortCountSelector) {
            childEls = childEls.filter(this.dropSortCountSelectorFilterFn);
        }
        // 如果没有主动删除则删除多余的originplaceholder
        if (childEls.some(el => el !== this.dragDropService.dragOriginPlaceholder
            && el.classList.contains('drag-origin-placeholder'))) {
            childEls = childEls.filter(el => !(el.classList.contains('drag-origin-placeholder')
                && el !== this.dragDropService.dragOriginPlaceholder));
        }
        // 要先删除clonenode否则placeholderindex是错的
        if (this.dragDropService.dragFollow && this.dragDropService.dragCloneNode) {
            const cloneNodeIndex = childEls.findIndex(value => value === this.dragDropService.dragCloneNode);
            if (-1 !== cloneNodeIndex) {
                childEls.splice(cloneNodeIndex, 1);
            }
        }
        // 计算index数组需要删除源占位符
        if (this.dragDropService.dragOriginPlaceholder) {
            const dragOriginPlaceholderIndex = childEls.findIndex(value => value === this.dragDropService.dragOriginPlaceholder);
            if (-1 !== dragOriginPlaceholderIndex) {
                this.dragElIndex = dragOriginPlaceholderIndex - 1;
                childEls.splice(dragOriginPlaceholderIndex, 1);
            }
            else {
                this.dragElIndex = -1;
            }
        }
        else {
            this.dragElIndex = -1;
        }
        // 查询是否已经插入了placeholder
        const placeholderIndex = childEls.findIndex(value => value.contains(this.placeholder));
        // 删除placeholder
        if (-1 !== placeholderIndex) {
            childEls.splice(placeholderIndex, 1);
        }
        // 如果还有placeholder在前面 dragElIndex得再减一
        if (-1 !== placeholderIndex && -1 !== this.dragElIndex && placeholderIndex < this.dragElIndex) {
            this.dragElIndex--;
        }
        const positionIndex = -1 !== placeholderIndex ? placeholderIndex : this.dragElIndex;
        const currentIndex = childEls.findIndex(value => (value.contains(moveElement)
            || value.nextElementSibling === moveElement
                && value.nextElementSibling.classList.contains('drag-origin-placeholder')));
        if (this.switchWhileCrossEdge && !this.allowDropOnItem && childEls.length
            && -1 !== positionIndex
            && currentIndex > -1) { // 越过元素边界立即交换位置算法
            const lastIndex = positionIndex;
            // 解决抖动
            const realEl = this.overElement && (this.overElement.realEl || this.overElement.el);
            if (-1 !== currentIndex && realEl === childEls[currentIndex]) {
                this.dropIndex = this.overElement.index;
                return this.overElement;
            }
            overElement = {
                index: lastIndex > currentIndex ? currentIndex : (currentIndex + 1),
                el: childEls[currentIndex],
                position: lastIndex > currentIndex ? 'before' : 'after'
            };
            this.dragDropService.dropOnItem = false;
            this.dropIndex = overElement.index;
            return overElement;
        }
        if (moveElement === this.sortContainer
            || moveElement.classList.contains('drag-origin-placeholder')
            || moveElement === (this.dragDropService && this.dragDropService.dragOriginPlaceholder)
            || (!this.sortContainer.contains(moveElement) && this.defaultDropPosition === 'closest')) {
            if (!childEls.length) {
                this.dropIndex = 0;
                this.dragDropService.dropOnItem = false;
                return overElement;
            }
            // 落入A元素和B元素的间隙里
            let findInGap = false;
            for (let i = 0; i < childEls.length; i++) {
                const targetElement = childEls[i];
                // 处理非越边的落到side-origin-placeholder
                if (childEls[i].nextSibling === moveElement
                    && moveElement.classList.contains('drag-origin-placeholder')) {
                    const position = this.calcPosition(event, moveElement);
                    this.dragDropService.dropOnItem = position === 'inside';
                    overElement = { index: position === 'after' ? (i + 1) : i, el: childEls[i], position: position };
                    this.dropIndex = overElement.index;
                    return overElement;
                }
                const positionOutside = this.calcPositionOutside(event, targetElement);
                if (positionOutside === 'before') {
                    this.dragDropService.dropOnItem = false;
                    overElement = { index: i, el: childEls[i], position: positionOutside, realEl: moveElement };
                    this.dropIndex = overElement.index;
                    findInGap = true;
                    break;
                }
                else {
                    // for 'notsure'
                }
            }
            if (!findInGap) {
                this.dragDropService.dropOnItem = false;
                overElement = { index: childEls.length, el: childEls[childEls.length - 1], position: 'after', realEl: moveElement };
                this.dropIndex = childEls.length;
            }
            return overElement;
        }
        if (!this.sortContainer.contains(moveElement)) {
            if (this.defaultDropPosition === 'before') {
                overElement = { index: 0, el: childEls.length ? childEls[0] : null, position: 'before', realEl: moveElement };
                this.dropFlag = 'beforeAll';
            }
            else {
                overElement = {
                    index: childEls.length,
                    el: childEls.length ? childEls[childEls.length - 1] : null,
                    position: 'after',
                    realEl: moveElement
                };
                this.dropFlag = 'afterAll';
            }
            this.dropIndex = overElement.index;
            return overElement;
        }
        let find = false;
        for (let i = 0; i < childEls.length; i++) {
            if (childEls[i].contains(moveElement)) {
                const targetElement = childEls[i];
                const position = this.calcPosition(event, targetElement);
                this.dragDropService.dropOnItem = position === 'inside';
                overElement = { index: position === 'after' ? (i + 1) : i, el: childEls[i], position: position };
                this.dropIndex = overElement.index;
                find = true;
                break;
            }
        }
        if (!find) {
            if (childEls.length) {
                overElement = { index: childEls.length, el: childEls[childEls.length - 1], position: 'after' };
            }
            this.dropIndex = childEls.length;
            this.dragDropService.dropOnItem = false;
        }
        return overElement;
    }
    calcPosition(event, targetElement) {
        const rect = targetElement.getBoundingClientRect();
        const relY = event.clientY - (rect.y || rect.top);
        const relX = event.clientX - (rect.x || rect.left);
        // 处理允许drop到元素自己
        if (this.allowDropOnItem) {
            const dropOnItemEdge = {
                height: (this.nestingTargetRect && this.nestingTargetRect.height || rect.height),
                width: (this.nestingTargetRect && this.nestingTargetRect.width || rect.width)
            };
            const threeQuartersOfHeight = dropOnItemEdge.height * 3 / 4;
            const threeQuartersOfWidth = dropOnItemEdge.width * 3 / 4;
            const AQuarterOfHeight = Number(dropOnItemEdge.height) / 4;
            const AQuarterOfWidth = Number(dropOnItemEdge.width) / 4;
            if (this.sortDirectionZMode) {
                const slashPosition = (relY / dropOnItemEdge.height + relX / dropOnItemEdge.width);
                if (slashPosition > 0.3 && slashPosition <= 0.7) {
                    return 'inside';
                }
                else if (slashPosition > 0.7) {
                    const slashPositionNesting = ((relY - rect.height + dropOnItemEdge.height) / dropOnItemEdge.height
                        + (relX - rect.width + dropOnItemEdge.width) / dropOnItemEdge.width);
                    if (slashPositionNesting <= 0.7) {
                        return 'inside';
                    }
                }
            }
            if ((this.sortDirection === 'v' && relY > AQuarterOfHeight && relY <= threeQuartersOfHeight) ||
                (this.sortDirection !== 'v' && relX > AQuarterOfWidth && relX <= threeQuartersOfWidth)) {
                //  高度的中间1/4 - 3/4 属于drop到元素自己
                return 'inside';
            }
            else if ((this.sortDirection === 'v' && relY > threeQuartersOfHeight
                && relY <= (rect.height - AQuarterOfHeight)) ||
                (this.sortDirection !== 'v' && relX > threeQuartersOfWidth
                    && relX <= (rect.width - AQuarterOfWidth))) {
                // 内嵌列表后中间区域都属于inside
                return 'inside';
            }
        }
        if (this.sortDirectionZMode) {
            if ((relY / rect.height + relX / rect.width) < 1) {
                return 'before';
            }
            return 'after';
        }
        // 其他情况保持原来的属于上半部分或者下半部分
        if ((this.sortDirection === 'v' && relY > (rect.height / 2)) ||
            (this.sortDirection !== 'v' && relX > (rect.width / 2))) {
            return 'after';
        }
        return 'before';
    }
    calcPositionOutside(event, targetElement) {
        const rect = this.getBoundingRectAndRealPosition(targetElement); // targetElement.getBoundingClientRect();
        const relY = event.clientY - (rect.y || rect.top);
        const relX = event.clientX - (rect.x || rect.left);
        if (this.sortDirectionZMode) {
            if ((this.sortDirection === 'v' && (relY < 0 || (relY < rect.height && relX < 0)))
                || (this.sortDirection !== 'v' && (relX < 0 || (relX < rect.width && relY < 0)))) {
                return 'before';
            }
            return 'notsure';
        }
        if ((this.sortDirection === 'v' && relY < (rect.height / 2)) ||
            (this.sortDirection !== 'v' && relX < (rect.width / 2))) {
            return 'before';
        }
        return 'notsure';
    }
    // 插入placeholder
    insertPlaceholder(overElement) {
        const tempScrollTop = this.sortContainer.scrollTop;
        const tempScrollLeft = this.sortContainer.scrollLeft;
        let hitPlaceholder = false;
        let cmd;
        const getIndex = (arr, el, defaultValue) => {
            const index = arr.indexOf(el);
            return index > -1 ? index : defaultValue;
        };
        if (null !== overElement) {
            const sortContainerChildren = Utils.slice(this.sortContainer.children).filter(el => el !== this.dragDropService.dragCloneNode);
            if (overElement.el === null) {
                cmd = {
                    command: 'append'
                };
                this.sortContainer.appendChild(this.placeholder);
            }
            else {
                if (overElement.position === 'inside') {
                    cmd = {
                        command: 'remove'
                    };
                    this.removePlaceholder();
                }
                else if (this.dragDropService.dragOriginPlaceholder && this.isDragPlaceholderPosition(overElement.index)) {
                    cmd = {
                        command: 'remove'
                    };
                    this.removePlaceholder();
                    hitPlaceholder = true;
                }
                else if (overElement.position === 'after') {
                    if (overElement.el.nextSibling && overElement.el.nextSibling.classList
                        && overElement.el.nextSibling.classList.contains('drag-origin-placeholder')) {
                        // 针对多源占位符场景
                        cmd = {
                            command: 'insertBefore',
                            index: getIndex(sortContainerChildren, overElement.el.nextSibling, sortContainerChildren.length) + 1
                        };
                        this.sortContainer.insertBefore(this.placeholder, overElement.el.nextSibling.nextSibling);
                    }
                    else {
                        cmd = {
                            command: 'insertBefore',
                            index: getIndex(sortContainerChildren, overElement.el, sortContainerChildren.length) + 1
                        };
                        this.sortContainer.insertBefore(this.placeholder, overElement.el.nextSibling);
                    }
                }
                else {
                    cmd = {
                        command: 'insertBefore',
                        index: getIndex(sortContainerChildren, overElement.el, sortContainerChildren.length)
                    };
                    this.sortContainer.insertBefore(this.placeholder, overElement.el);
                }
            }
        }
        this.placeholderInsertionEvent.next(cmd);
        this.sortContainer.scrollTop = tempScrollTop;
        this.sortContainer.scrollLeft = tempScrollLeft;
        if (this.dragDropService.dragOriginPlaceholder) {
            if (hitPlaceholder) {
                this.hitDragOriginPlaceholder();
            }
            else {
                this.hitDragOriginPlaceholder(false);
            }
        }
    }
    isDragPlaceholderPosition(index) {
        if (this.dragElIndex > -1 && (index === this.dragElIndex || index === this.dragElIndex + 1)) {
            return true;
        }
        else {
            return false;
        }
    }
    hitDragOriginPlaceholder(bool = true) {
        const placeholder = this.dragDropService.dragOriginPlaceholder;
        if (bool) {
            placeholder.classList.add('hit-origin-placeholder');
        }
        else {
            placeholder.classList.remove('hit-origin-placeholder');
        }
    }
    removePlaceholder() {
        if (this.sortContainer && this.sortContainer.contains(this.placeholder)) {
            this.sortContainer.removeChild(this.placeholder);
            this.placeholderInsertionEvent.next({
                command: 'remove'
            });
        }
    }
    removeDragoverItemClass(container, overElement) {
        if (this.dragOverItemClass) {
            const dragOverItemClassGroup = container.querySelectorAll('.' + this.dragOverItemClass);
            if (dragOverItemClassGroup && dragOverItemClassGroup.length > 0) {
                for (const element of dragOverItemClassGroup) {
                    if (overElement) {
                        if (element !== overElement.el || overElement.position !== 'inside') {
                            Utils.removeClass(element, this.dragOverItemClass);
                        }
                    }
                    else {
                        Utils.removeClass(element, this.dragOverItemClass);
                    }
                }
            }
        }
    }
    checkSelfFromIndex(el) {
        let fromIndex = -1;
        if (!this.sortContainer.contains(el)) {
            return fromIndex;
        }
        let childs = Utils.slice(this.sortContainer.children);
        if (this.dropSortCountSelector) {
            childs = childs.filter(this.dropSortCountSelectorFilterFn);
        }
        for (let i = 0; i < childs.length; i++) {
            if (childs[i].contains(this.dragDropService.draggedEl)) {
                fromIndex = i;
                break;
            }
        }
        return this.getRealIndex(fromIndex);
    }
    getRealIndex(index, flag) {
        let realIndex;
        const startIndex = this.dropSortVirtualScrollOption && this.dropSortVirtualScrollOption.startIndex || 0;
        const totalLength = this.dropSortVirtualScrollOption && this.dropSortVirtualScrollOption.totalLength;
        if (flag === 'beforeAll') {
            realIndex = 0;
        }
        else if (flag === 'afterAll') {
            realIndex = totalLength || index;
        }
        else {
            realIndex = startIndex + index;
        }
        return realIndex;
    }
    getBoundingRectAndRealPosition(targetElement) {
        // 用于修复部分display none的元素获取到的top和left是0， 取它下一个元素的左上角为坐标
        let rect = targetElement.getBoundingClientRect();
        const { bottom, right, width, height } = rect;
        if (rect.width === 0 && rect.height === 0 &&
            (targetElement.style.display === 'none' || getComputedStyle(targetElement).display === 'none')) {
            if (targetElement.nextElementSibling) {
                const { top: realTop, left: realLeft } = targetElement.nextElementSibling.getBoundingClientRect();
                rect = { x: realLeft, y: realTop, top: realTop, left: realLeft, bottom, right, width, height };
            }
        }
        return rect;
    }
    getSortContainer() {
        return this.sortContainer;
    }
}
DroppableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DroppableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: DragDropService }, { token: i0.NgZone }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });
DroppableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: DroppableDirective, selector: "[dDroppable]", inputs: { dragOverClass: "dragOverClass", dropScope: "dropScope", placeholderTag: "placeholderTag", placeholderStyle: "placeholderStyle", placeholderText: "placeholderText", allowDropOnItem: "allowDropOnItem", dragOverItemClass: "dragOverItemClass", nestingTargetRect: "nestingTargetRect", switchWhileCrossEdge: "switchWhileCrossEdge", defaultDropPosition: "defaultDropPosition", dropSortCountSelector: "dropSortCountSelector", dropSortVirtualScrollOption: "dropSortVirtualScrollOption" }, outputs: { dragEnterEvent: "dragEnterEvent", dragOverEvent: "dragOverEvent", dragLeaveEvent: "dragLeaveEvent", dropEvent: "dropEvent" }, host: { listeners: { "drop": "drop($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DroppableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dDroppable]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DragDropService }, { type: i0.NgZone }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { dragEnterEvent: [{
                type: Output
            }], dragOverEvent: [{
                type: Output
            }], dragLeaveEvent: [{
                type: Output
            }], dropEvent: [{
                type: Output
            }], dragOverClass: [{
                type: Input
            }], dropScope: [{
                type: Input
            }], placeholderTag: [{
                type: Input
            }], placeholderStyle: [{
                type: Input
            }], placeholderText: [{
                type: Input
            }], allowDropOnItem: [{
                type: Input
            }], dragOverItemClass: [{
                type: Input
            }], nestingTargetRect: [{
                type: Input
            }], switchWhileCrossEdge: [{
                type: Input
            }], defaultDropPosition: [{
                type: Input
            }], dropSortCountSelector: [{
                type: Input
            }], dropSortVirtualScrollOption: [{
                type: Input
            }], drop: [{
                type: HostListener,
                args: ['drop', ['$event']]
            }] } });

class DropSortSyncDirective extends DescendantChildren {
    constructor(el, droppable, dragDropSyncService, dropSortSyncDrs) {
        super(dropSortSyncDrs);
        this.el = el;
        this.droppable = droppable;
        this.dragDropSyncService = dragDropSyncService;
        this.dropSortSyncDrs = dropSortSyncDrs;
        this.dropSyncGroup = '';
        this.direction = 'v'; // 与sortContainer正交的方向
        this.subscription = new Subscription();
        this.subRenderEvent = (nativeStyle) => {
            this.syncGroupDirectives = this.dragDropSyncService.getDropSyncByGroup(this.dropSyncGroup).filter(directive => directive !== this);
            this.syncGroupDirectives.forEach(dir => {
                dir.renderPlaceholder(nativeStyle, this.droppable);
            });
        };
        this.subInsertionEvent = (cmd) => {
            this.syncGroupDirectives = this.dragDropSyncService.getDropSyncByGroup(this.dropSyncGroup).filter(directive => directive !== this);
            this.syncGroupDirectives.forEach(dir => {
                dir.insertPlaceholderCommand({
                    command: cmd.command,
                    container: dir.sortContainer,
                    relatedEl: dir.getChildrenElByIndex(dir.sortContainer, cmd.index)
                });
            });
        };
        this.descendantItem = this;
    }
    ngOnInit() {
        this.sortContainer = this.el.nativeElement;
        if (this.droppable) {
            this.sortContainer = this.droppable.getSortContainer();
            this.subscription.add(this.droppable.placeholderInsertionEvent.subscribe(this.subInsertionEvent)).add(this.droppable.placeholderRenderEvent.subscribe(this.subRenderEvent));
        }
        super.ngOnInit();
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    getChildrenElByIndex(target, index) {
        if (index === undefined || target && target.children && target.children.length < index || index < 0) {
            return null;
        }
        return this.sortContainer.children.item(index);
    }
    renderPlaceholder(nativeStyle, droppable) {
        if (!this.placeholder) {
            this.placeholder = document.createElement(droppable.placeholderTag);
            this.placeholder.className = 'drag-placeholder';
            this.placeholder.classList.add('drag-sync-placeholder');
            this.placeholder.innerText = droppable.placeholderText;
        }
        const { width, height } = nativeStyle;
        if (this.direction === 'v') {
            this.placeholder.style.width = width + 'px';
            this.placeholder.style.height = this.sortContainer.getBoundingClientRect().height + 'px';
        }
        else {
            this.placeholder.style.height = height + 'px';
            this.placeholder.style.width = this.sortContainer.getBoundingClientRect().width + 'px';
        }
        Utils.addElStyles(this.placeholder, droppable.placeholderStyle);
    }
    insertPlaceholderCommand(cmd) {
        if (cmd.command === 'insertBefore' && cmd.container) {
            cmd.container.insertBefore(this.placeholder, cmd.relatedEl);
            return;
        }
        if (cmd.command === 'append' && cmd.container) {
            cmd.container.appendChild(this.placeholder);
            return;
        }
        if (cmd.command === 'remove' && cmd.container) {
            if (cmd.container.contains(this.placeholder)) {
                cmd.container.removeChild(this.placeholder);
            }
            return;
        }
    }
}
DropSortSyncDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DropSortSyncDirective, deps: [{ token: i0.ElementRef }, { token: DroppableDirective, optional: true, self: true }, { token: DragDropSyncService }, { token: DropSortSyncDescendantRegisterService }], target: i0.ɵɵFactoryTarget.Directive });
DropSortSyncDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: DropSortSyncDirective, selector: "[dDropSortSync]", inputs: { dropSyncGroup: ["dDropSortSync", "dropSyncGroup"], direction: ["dropSyncDirection", "direction"] }, exportAs: ["dDropSortSync"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DropSortSyncDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dDropSortSync]',
                    exportAs: 'dDropSortSync'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: DroppableDirective, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: DragDropSyncService }, { type: DropSortSyncDescendantRegisterService }]; }, propDecorators: { dropSyncGroup: [{
                type: Input,
                args: ['dDropSortSync']
            }], direction: [{
                type: Input,
                args: ['dropSyncDirection']
            }] } });

/**
 * Makes an element draggable by adding the draggable html attribute
 */
class SortableDirective {
    constructor(el) {
        this.el = el;
        this.dSortDirection = 'v';
        this.dSortableZMode = false;
        this.dSortable = true;
    }
}
SortableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: SortableDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
SortableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: SortableDirective, selector: "[dSortable]", inputs: { dSortDirection: ["dSortable", "dSortDirection"], dSortableZMode: "dSortableZMode" }, host: { properties: { "attr.dsortable": "this.dSortDirection", "attr.d-sortable-zmode": "this.dSortableZMode", "attr.d-sortable": "this.dSortable" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: SortableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dSortable]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { dSortDirection: [{
                type: HostBinding,
                args: ['attr.dsortable']
            }, {
                type: Input,
                args: ['dSortable']
            }], dSortableZMode: [{
                type: HostBinding,
                args: ['attr.d-sortable-zmode']
            }, {
                type: Input
            }], dSortable: [{
                type: HostBinding,
                args: ['attr.d-sortable']
            }] } });

class DragDropModule {
}
DragDropModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DragDropModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropModule, declarations: [DraggableDirective,
        DroppableDirective,
        SortableDirective,
        DropScrollEnhancedDirective,
        DropScrollEnhancedSideDirective,
        BatchDraggableDirective,
        DragSyncDirective,
        DropSortSyncDirective,
        DragDropSyncBoxDirective,
        DragPreviewDirective,
        DragPreviewComponent,
        DragPreviewCloneDomRefComponent], imports: [CommonModule], exports: [DraggableDirective,
        DroppableDirective,
        SortableDirective,
        DropScrollEnhancedDirective,
        DropScrollEnhancedSideDirective,
        BatchDraggableDirective,
        DragSyncDirective,
        DropSortSyncDirective,
        DragDropSyncBoxDirective,
        DragPreviewDirective,
        DragPreviewComponent,
        DragPreviewCloneDomRefComponent] });
DragDropModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropModule, providers: [
        DragDropService
    ], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: DragDropModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [
                        DraggableDirective,
                        DroppableDirective,
                        SortableDirective,
                        DropScrollEnhancedDirective,
                        DropScrollEnhancedSideDirective,
                        BatchDraggableDirective,
                        DragSyncDirective,
                        DropSortSyncDirective,
                        DragDropSyncBoxDirective,
                        DragPreviewDirective,
                        DragPreviewComponent,
                        DragPreviewCloneDomRefComponent,
                    ],
                    exports: [
                        DraggableDirective,
                        DroppableDirective,
                        SortableDirective,
                        DropScrollEnhancedDirective,
                        DropScrollEnhancedSideDirective,
                        BatchDraggableDirective,
                        DragSyncDirective,
                        DropSortSyncDirective,
                        DragDropSyncBoxDirective,
                        DragPreviewDirective,
                        DragPreviewComponent,
                        DragPreviewCloneDomRefComponent,
                    ],
                    providers: [
                        DragDropService
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BatchDraggableDirective, DescendantChildren, DescendantRegisterService, DescendantRoot, DragDropModule, DragDropService, DragDropSyncBoxDirective, DragDropSyncService, DragPreviewCloneDomRefComponent, DragPreviewComponent, DragPreviewDirective, DragSyncDescendantRegisterService, DragSyncDirective, DraggableDirective, DropEvent, DropScrollEnhancedDirective, DropScrollEnhancedSideDirective, DropSortSyncDescendantRegisterService, DropSortSyncDirective, DroppableDirective, PreserveNextEventEmitter, SortableDirective };
//# sourceMappingURL=ng-devui-dragdrop.mjs.map
