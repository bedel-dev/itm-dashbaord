import { trigger, state, style, transition, animate } from '@angular/animations';
import * as i0 from '@angular/core';
import { TemplateRef, Component, Input, HostBinding, HostListener, ElementRef, Directive, Inject, NgModule } from '@angular/core';
import * as i1 from 'ng-devui/position';
import { PositioningModule } from 'ng-devui/position';
import { Subscription, fromEvent, of } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import * as i2 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i1$1 from 'ng-devui/overlay-container';
import { OverlayContainerModule } from 'ng-devui/overlay-container';

class ReadTipComponent {
    constructor(renderer, positionService, elementRef, cdr) {
        this.renderer = renderer;
        this.positionService = positionService;
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.position = 'top';
        this.showAnimate = false;
        this.zIndex = 1060;
        this.subs = new Subscription();
        this.SCROLL_REFRESH_INTERVAL = 100;
        this.animateState = this.showAnimate ? 'void' : '';
    }
    get display() {
        return this.content ? 'block' : 'none';
    }
    get class() {
        return 'devui-popover ' + this.currentPosition + ' ' + this.connectionBias;
    }
    get state() {
        return this.animateState;
    }
    get template() {
        return this.content instanceof TemplateRef ? this.content : null;
    }
    ngOnInit() {
        this.elementRef.nativeElement.style.zIndex = this.zIndex;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.updatePosition();
        });
        if (this.appendToBody) {
            if (!this.scrollElement) {
                this.scrollElement = this.positionService.getScrollParent(this.triggerElementRef.nativeElement);
            }
            this.subs.add(fromEvent(this.scrollElement || window, 'scroll')
                .pipe(debounceTime(this.SCROLL_REFRESH_INTERVAL))
                .subscribe(() => {
                this.updatePosition();
            }));
            this.subs.add(fromEvent(window, 'resize')
                .pipe(debounceTime(this.SCROLL_REFRESH_INTERVAL))
                .subscribe(() => {
                this.updatePosition();
            }));
        }
    }
    ngAfterContentChecked() {
        this.updatePosition();
    }
    show() {
        this.animateState = 'visible';
    }
    hide() {
        this.animateState = 'void';
    }
    onHidden() { }
    onAnimationEnd(event) {
        if (event.toState === 'void') {
            this.onHidden();
        }
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    updatePosition() {
        const rect = this.positionService.positionElements(this.triggerElementRef.nativeElement, this.elementRef.nativeElement, this.position, this.appendToBody);
        this.currentPosition = rect.placementPrimary;
        this.connectionBias = `bias-${rect.placementSecondary}`;
        if (rect.placementSecondary === 'center') {
            if (rect.placementPrimary === 'left' || rect.placementPrimary === 'right') {
                this.connectionBias = 'bias-vertical-center';
            }
            else {
                this.connectionBias = 'bias-horizontal-center';
            }
        }
        this.renderer.setStyle(this.elementRef.nativeElement, 'left', `${rect.left}px`);
        this.renderer.setStyle(this.elementRef.nativeElement, 'top', `${rect.top}px`);
    }
}
ReadTipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: ReadTipComponent, deps: [{ token: i0.Renderer2 }, { token: i1.PositionService }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ReadTipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.3", type: ReadTipComponent, selector: "d-read-tip", inputs: { triggerElementRef: "triggerElementRef", position: "position", content: "content", customData: "customData", title: "title", showAnimate: "showAnimate", scrollElement: "scrollElement", appendToBody: "appendToBody", zIndex: "zIndex", popMaxWidth: "popMaxWidth", overlayClassName: "overlayClassName" }, host: { listeners: { "@state.done": "onAnimationEnd($event)" }, properties: { "style.display": "this.display", "class": "this.class", "@state": "this.state" } }, ngImport: i0, template: "<div class=\"arrow\"></div>\n<div class=\"devui-popover-content {{ overlayClassName }}\" [style.maxWidth.px]=\"popMaxWidth\">\n  <ng-template [ngTemplateOutlet]=\"template || defaultTemplate\" [ngTemplateOutletContext]=\"{ $implicit: customData }\"> </ng-template>\n  <ng-template #defaultTemplate>\n    <div class=\"read-tip-container\">\n      <div class=\"title\">\n        {{ title }}\n      </div>\n      <div class=\"content\">\n        {{ content }}\n      </div>\n    </div>\n  </ng-template>\n</div>\n", styles: [".devui-font-size-base{font-size:12px;font-size:var(--devui-font-size, 12px)}.devui-font-base{font-size:12px;font-size:var(--devui-font-size, 12px);font-weight:400;line-height:1.5}.devui-font-size-modal-title{font-size:18px;font-size:var(--devui-font-size-modal-title, 18px)}.devui-font-modal-title{font-size:18px;font-size:var(--devui-font-size-modal-title, 18px);font-weight:700;line-height:1.5}.devui-font-size-page-title{font-size:16px;font-size:var(--devui-font-size-page-title, 16px)}.devui-font-page-title{font-size:16px;font-size:var(--devui-font-size-page-title, 16px);font-weight:700;line-height:1.5}.devui-font-size-secondary-title{font-size:14px;font-size:var(--devui-font-size-card-title, 14px)}.devui-font-secondary-title{font-size:14px;font-size:var(--devui-font-size-card-title, 14px);font-weight:700;line-height:1.5}:host.devui-popover{font-size:12px;font-size:var(--devui-font-size, 12px);position:absolute;top:0;left:0;line-height:1.5;border:none;border-radius:4px;border-radius:var(--devui-border-radius-feedback, 4px);z-index:1060;z-index:var(--devui-z-index-pop-up, 1060);background-color:#464d6e;background-color:var(--devui-feedback-overlay-bg, #464d6e);color:#dfe1e6;color:var(--devui-feedback-overlay-text, #dfe1e6);overflow-wrap:break-word}:host.devui-popover>.arrow{border-width:8px}:host.devui-popover>.arrow,:host.devui-popover>.arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}:host.devui-popover>.arrow:after{content:\"\"}:host.devui-popover.top>.arrow{transform:translate(-50%);border-bottom-width:0;border-top-color:#464d6e;border-top-color:var(--devui-feedback-overlay-bg, #464d6e);bottom:-8px}:host.devui-popover.right>.arrow{left:-8px;margin-top:-8px;border-left-width:0;border-right-color:#464d6e;border-right-color:var(--devui-feedback-overlay-bg, #464d6e)}:host.devui-popover.bottom>.arrow{transform:translate(-50%);border-top-width:0;border-bottom-color:#464d6e;border-bottom-color:var(--devui-feedback-overlay-bg, #464d6e);top:-8px}:host.devui-popover.left>.arrow{right:-8px;margin-top:-8px;border-right-width:0;border-left-color:#464d6e;border-left-color:var(--devui-feedback-overlay-bg, #464d6e)}:host.devui-popover.bias-left>.arrow{left:14px}:host.devui-popover.bias-right>.arrow{right:14px}:host.devui-popover.bias-top>.arrow{top:13px}:host.devui-popover.bias-bottom>.arrow{bottom:5px}:host.devui-popover.bias-horizontal-center>.arrow{left:50%}:host.devui-popover.bias-vertical-center>.arrow{top:50%}:host.devui-popover.top{margin-top:-8px;box-shadow:0 4px 16px rgba(37,43,58,.2);box-shadow:var(--devui-shadow-length-feedback-overlay, 0 4px 16px 0) var(--devui-shadow, rgba(37, 43, 58, .2))}:host.devui-popover.bottom{margin-top:8px;box-shadow:0 4px 16px rgba(37,43,58,.2);box-shadow:var(--devui-shadow-length-feedback-overlay, 0 4px 16px 0) var(--devui-shadow, rgba(37, 43, 58, .2))}:host.devui-popover.left{margin-left:-8px;box-shadow:0 4px 16px rgba(37,43,58,.2);box-shadow:var(--devui-shadow-length-feedback-overlay, 0 4px 16px 0) var(--devui-shadow, rgba(37, 43, 58, .2))}:host.devui-popover.right{margin-left:8px;box-shadow:0 4px 16px rgba(37,43,58,.2);box-shadow:var(--devui-shadow-length-feedback-overlay, 0 4px 16px 0) var(--devui-shadow, rgba(37, 43, 58, .2))}.devui-popover-content .read-tip-container .title{font-size:16px;font-size:var(--devui-font-size-page-title, 16px)}.devui-popover-content .read-tip-container .content{font-size:12px;font-size:var(--devui-font-size, 12px)}.devui-popover-icon{display:block;position:absolute;left:10px;top:6px}.devui-popover-icon svg.devui-icon{width:16px;height:16px}.devui-popover-main-content.with-icon{text-indent:20px}.devui-icon.devui-icon-success>g>path{fill:#50d4ab;fill:var(--devui-success, #50d4ab)}.devui-icon.devui-icon-success>g>circle,.devui-icon.devui-icon-success>g>polygon{fill:#fff;fill:var(--devui-light-text, #ffffff)}.devui-icon.devui-icon-warning>g>polygon{fill:#fff;fill:var(--devui-light-text, #ffffff)}.devui-icon.devui-icon-warning>g>path{fill:#fac20a;fill:var(--devui-warning, #fac20a)}.devui-icon.devui-icon-info>g>g{fill:#5e7ce0;fill:var(--devui-info, #5e7ce0)}.devui-icon.devui-icon-info>g>circle{fill:#fff;fill:var(--devui-light-text, #ffffff)}.devui-icon.devui-icon-error>g>path{fill:#f66f6a;fill:var(--devui-danger, #f66f6a)}.devui-icon.devui-icon-error>g>circle{fill:#fff;fill:var(--devui-light-text, #ffffff)}.devui-popover-content{padding:4px 12px}\n"], directives: [{ type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], animations: [
        trigger('state', [
            state('void', style({ opacity: 0 })),
            state('visible', style({ opacity: 1 })),
            transition('* => visible', animate('150ms cubic-bezier(0.0, 0.0, 0.2, 1)')),
            transition('visible => *', animate('150ms cubic-bezier(0.4, 0.0, 1, 1)')),
        ]),
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: ReadTipComponent, decorators: [{
            type: Component,
            args: [{ selector: 'd-read-tip', animations: [
                        trigger('state', [
                            state('void', style({ opacity: 0 })),
                            state('visible', style({ opacity: 1 })),
                            transition('* => visible', animate('150ms cubic-bezier(0.0, 0.0, 0.2, 1)')),
                            transition('visible => *', animate('150ms cubic-bezier(0.4, 0.0, 1, 1)')),
                        ]),
                    ], template: "<div class=\"arrow\"></div>\n<div class=\"devui-popover-content {{ overlayClassName }}\" [style.maxWidth.px]=\"popMaxWidth\">\n  <ng-template [ngTemplateOutlet]=\"template || defaultTemplate\" [ngTemplateOutletContext]=\"{ $implicit: customData }\"> </ng-template>\n  <ng-template #defaultTemplate>\n    <div class=\"read-tip-container\">\n      <div class=\"title\">\n        {{ title }}\n      </div>\n      <div class=\"content\">\n        {{ content }}\n      </div>\n    </div>\n  </ng-template>\n</div>\n", styles: [".devui-font-size-base{font-size:12px;font-size:var(--devui-font-size, 12px)}.devui-font-base{font-size:12px;font-size:var(--devui-font-size, 12px);font-weight:400;line-height:1.5}.devui-font-size-modal-title{font-size:18px;font-size:var(--devui-font-size-modal-title, 18px)}.devui-font-modal-title{font-size:18px;font-size:var(--devui-font-size-modal-title, 18px);font-weight:700;line-height:1.5}.devui-font-size-page-title{font-size:16px;font-size:var(--devui-font-size-page-title, 16px)}.devui-font-page-title{font-size:16px;font-size:var(--devui-font-size-page-title, 16px);font-weight:700;line-height:1.5}.devui-font-size-secondary-title{font-size:14px;font-size:var(--devui-font-size-card-title, 14px)}.devui-font-secondary-title{font-size:14px;font-size:var(--devui-font-size-card-title, 14px);font-weight:700;line-height:1.5}:host.devui-popover{font-size:12px;font-size:var(--devui-font-size, 12px);position:absolute;top:0;left:0;line-height:1.5;border:none;border-radius:4px;border-radius:var(--devui-border-radius-feedback, 4px);z-index:1060;z-index:var(--devui-z-index-pop-up, 1060);background-color:#464d6e;background-color:var(--devui-feedback-overlay-bg, #464d6e);color:#dfe1e6;color:var(--devui-feedback-overlay-text, #dfe1e6);overflow-wrap:break-word}:host.devui-popover>.arrow{border-width:8px}:host.devui-popover>.arrow,:host.devui-popover>.arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}:host.devui-popover>.arrow:after{content:\"\"}:host.devui-popover.top>.arrow{transform:translate(-50%);border-bottom-width:0;border-top-color:#464d6e;border-top-color:var(--devui-feedback-overlay-bg, #464d6e);bottom:-8px}:host.devui-popover.right>.arrow{left:-8px;margin-top:-8px;border-left-width:0;border-right-color:#464d6e;border-right-color:var(--devui-feedback-overlay-bg, #464d6e)}:host.devui-popover.bottom>.arrow{transform:translate(-50%);border-top-width:0;border-bottom-color:#464d6e;border-bottom-color:var(--devui-feedback-overlay-bg, #464d6e);top:-8px}:host.devui-popover.left>.arrow{right:-8px;margin-top:-8px;border-right-width:0;border-left-color:#464d6e;border-left-color:var(--devui-feedback-overlay-bg, #464d6e)}:host.devui-popover.bias-left>.arrow{left:14px}:host.devui-popover.bias-right>.arrow{right:14px}:host.devui-popover.bias-top>.arrow{top:13px}:host.devui-popover.bias-bottom>.arrow{bottom:5px}:host.devui-popover.bias-horizontal-center>.arrow{left:50%}:host.devui-popover.bias-vertical-center>.arrow{top:50%}:host.devui-popover.top{margin-top:-8px;box-shadow:0 4px 16px rgba(37,43,58,.2);box-shadow:var(--devui-shadow-length-feedback-overlay, 0 4px 16px 0) var(--devui-shadow, rgba(37, 43, 58, .2))}:host.devui-popover.bottom{margin-top:8px;box-shadow:0 4px 16px rgba(37,43,58,.2);box-shadow:var(--devui-shadow-length-feedback-overlay, 0 4px 16px 0) var(--devui-shadow, rgba(37, 43, 58, .2))}:host.devui-popover.left{margin-left:-8px;box-shadow:0 4px 16px rgba(37,43,58,.2);box-shadow:var(--devui-shadow-length-feedback-overlay, 0 4px 16px 0) var(--devui-shadow, rgba(37, 43, 58, .2))}:host.devui-popover.right{margin-left:8px;box-shadow:0 4px 16px rgba(37,43,58,.2);box-shadow:var(--devui-shadow-length-feedback-overlay, 0 4px 16px 0) var(--devui-shadow, rgba(37, 43, 58, .2))}.devui-popover-content .read-tip-container .title{font-size:16px;font-size:var(--devui-font-size-page-title, 16px)}.devui-popover-content .read-tip-container .content{font-size:12px;font-size:var(--devui-font-size, 12px)}.devui-popover-icon{display:block;position:absolute;left:10px;top:6px}.devui-popover-icon svg.devui-icon{width:16px;height:16px}.devui-popover-main-content.with-icon{text-indent:20px}.devui-icon.devui-icon-success>g>path{fill:#50d4ab;fill:var(--devui-success, #50d4ab)}.devui-icon.devui-icon-success>g>circle,.devui-icon.devui-icon-success>g>polygon{fill:#fff;fill:var(--devui-light-text, #ffffff)}.devui-icon.devui-icon-warning>g>polygon{fill:#fff;fill:var(--devui-light-text, #ffffff)}.devui-icon.devui-icon-warning>g>path{fill:#fac20a;fill:var(--devui-warning, #fac20a)}.devui-icon.devui-icon-info>g>g{fill:#5e7ce0;fill:var(--devui-info, #5e7ce0)}.devui-icon.devui-icon-info>g>circle{fill:#fff;fill:var(--devui-light-text, #ffffff)}.devui-icon.devui-icon-error>g>path{fill:#f66f6a;fill:var(--devui-danger, #f66f6a)}.devui-icon.devui-icon-error>g>circle{fill:#fff;fill:var(--devui-light-text, #ffffff)}.devui-popover-content{padding:4px 12px}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i1.PositionService }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { triggerElementRef: [{
                type: Input
            }], position: [{
                type: Input
            }], content: [{
                type: Input
            }], customData: [{
                type: Input
            }], title: [{
                type: Input
            }], showAnimate: [{
                type: Input
            }], scrollElement: [{
                type: Input
            }], appendToBody: [{
                type: Input
            }], zIndex: [{
                type: Input
            }], popMaxWidth: [{
                type: Input
            }], overlayClassName: [{
                type: Input
            }], display: [{
                type: HostBinding,
                args: ['style.display']
            }], class: [{
                type: HostBinding,
                args: ['class']
            }], state: [{
                type: HostBinding,
                args: ['@state']
            }], onAnimationEnd: [{
                type: HostListener,
                args: ['@state.done', ['$event']]
            }] } });

class ReadTipDirective {
    constructor(el, componentFactoryResolver, overlayContainerRef, inject, viewContainerRef, doc) {
        this.el = el;
        this.componentFactoryResolver = componentFactoryResolver;
        this.overlayContainerRef = overlayContainerRef;
        this.inject = inject;
        this.viewContainerRef = viewContainerRef;
        this.doc = doc;
        this.defaultOptions = {
            trigger: 'hover',
            showAnimate: false,
            mouseenterTime: 100,
            mouseleaveTime: 100,
            position: 'top',
            overlayClassName: '',
            appendToBody: true,
            rules: { selector: null },
        };
        this.onDocumentClick = (event) => {
            event.stopPropagation();
            if (!this.el.nativeElement.contains(event.target) &&
                !(this.readTipComponentRef && this.readTipComponentRef.instance.elementRef.nativeElement.contains(event.target))) {
                this.hide();
            }
        };
        this.document = this.doc;
    }
    set prevTarget(target) {
        if (target !== this._prevTarget) {
            this._prevTarget = target;
            this.hide();
        }
    }
    onMouseOver(event) {
        this.findElementIndex(event.target, this.readTipOptions?.rules, 'hover').subscribe((elementInfo) => {
            if (elementInfo?.shouldTrigger) {
                this.hide();
                if (!this.readTipComponentRef) {
                    const target = new ElementRef(event.target);
                    setTimeout(() => {
                        this.show(target, elementInfo.rule);
                    }, elementInfo.rule?.mouseenterTime);
                }
                if (this.readTipComponentRef) {
                    setTimeout(() => {
                        if (this.readTipComponentRef) {
                            this.readTipComponentRef.instance.updatePosition();
                        }
                    }, elementInfo.rule?.mouseenterTime);
                }
            }
        });
    }
    onMouseOut(event) {
        this.findElementIndex(event.target, this.readTipOptions?.rules, 'hover').subscribe((elementInfo) => {
            if (elementInfo?.shouldTrigger) {
                setTimeout(() => {
                    this.hide();
                }, elementInfo.rule?.mouseleaveTime);
            }
        });
    }
    onClick(event) {
        this.findElementIndex(event.target, this.readTipOptions?.rules, 'click').subscribe((elementInfo) => {
            this.prevTarget = event.target;
            if (elementInfo?.shouldTrigger) {
                if (!this.readTipComponentRef) {
                    const target = new ElementRef(event.target);
                    this.show(target, elementInfo.rule);
                }
                if (this.readTipComponentRef) {
                    setTimeout(() => {
                        if (this.readTipComponentRef) {
                            this.readTipComponentRef.instance.updatePosition();
                        }
                    });
                }
            }
        });
    }
    ngOnInit() { }
    ngOnDestroy() {
        this.destroy();
    }
    show(target, rule) {
        this.hide();
        if (!this.readTipComponentRef) {
            this.createReadTip(target, rule);
        }
        if (rule.showAnimate) {
            this.readTipComponentRef.instance.show();
        }
        if (rule.trigger === 'click') {
            this.document.addEventListener('click', this.onDocumentClick);
        }
    }
    createReadTip(target, rule) {
        if (rule.appendToBody) {
            this.readTipComponentRef = this.overlayContainerRef.createComponent(this.componentFactoryResolver.resolveComponentFactory(ReadTipComponent));
        }
        else {
            this.readTipComponentRef = this.viewContainerRef.createComponent(this.componentFactoryResolver.resolveComponentFactory(ReadTipComponent), this.viewContainerRef.length, this.inject);
        }
        if (this.contentTemplate) {
            Object.assign(this.readTipComponentRef.instance, {
                content: this.contentTemplate,
                triggerElementRef: target,
                appendToBody: rule.appendToBody,
                position: rule.position,
                overlayClassName: rule.overlayClassName,
            });
        }
        else {
            if (rule.dataFn) {
                rule.dataFn({ element: target.nativeElement, rule }).subscribe((data) => {
                    if (data.template) {
                        Object.assign(this.readTipComponentRef.instance, {
                            content: data.template,
                            customData: data.customData,
                            triggerElementRef: target,
                            appendToBody: rule.appendToBody,
                            position: rule.position,
                            overlayClassName: rule.overlayClassName,
                        });
                    }
                    else {
                        Object.assign(this.readTipComponentRef.instance, {
                            content: data.content,
                            title: data.title,
                            triggerElementRef: target,
                            appendToBody: rule.appendToBody,
                            position: rule.position,
                            overlayClassName: rule.overlayClassName,
                        });
                    }
                });
            }
            else {
                Object.assign(this.readTipComponentRef.instance, {
                    content: rule.content,
                    title: rule.title,
                    triggerElementRef: target,
                    appendToBody: rule.appendToBody,
                    position: rule.position,
                    overlayClassName: rule.overlayClassName,
                });
            }
        }
    }
    hide() {
        if (this.readTipComponentRef) {
            if (!this.readTipOptions.showAnimate) {
                this.destroy();
                return;
            }
            this.readTipComponentRef.instance.hide();
            this.readTipComponentRef.instance.onHidden = () => {
                this.destroy();
            };
        }
    }
    destroy() {
        if (this.readTipComponentRef) {
            this.readTipComponentRef.destroy();
            this.readTipComponentRef = null;
        }
        if (this.readTipOptions.trigger === 'click') {
            this.document.removeEventListener('click', this.onDocumentClick);
        }
    }
    findElementIndex(element, rules, trigger) {
        const keysCanInherit = ['trigger', 'showAnimate', 'mouseenterTime', 'mouseleaveTime', 'position', 'overlayClassName', 'appendToBody'];
        if (rules instanceof Array) {
            let elementIndex = -1;
            for (let i = 0; i < rules.length; i++) {
                if (this.isCorrectElement(rules[i].selector, element)) {
                    elementIndex = i;
                    break;
                }
            }
            keysCanInherit.forEach((key) => {
                if (rules[elementIndex]) {
                    rules[elementIndex][key] = rules[elementIndex][key] || this.readTipOptions[key] || this.defaultOptions[key];
                }
            });
            return of({
                shouldTrigger: rules[elementIndex]?.trigger === trigger && this.isCorrectElement(rules[elementIndex]?.selector, element),
                rule: rules[elementIndex],
            });
        }
        else {
            keysCanInherit.forEach((key) => {
                if (rules) {
                    rules[key] = rules[key] || this.readTipOptions[key] || this.defaultOptions[key];
                }
            });
            return of({
                shouldTrigger: rules?.trigger === trigger && this.isCorrectElement(rules?.selector, element),
                rule: rules,
            });
        }
    }
    isCorrectElement(selector, element) {
        const elementsArray = this.el.nativeElement.querySelectorAll(selector);
        for (let i = 0; i < elementsArray.length; i++) {
            if (elementsArray[i] === element) {
                return true;
            }
        }
        return false;
    }
}
ReadTipDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: ReadTipDirective, deps: [{ token: i0.ElementRef }, { token: i0.ComponentFactoryResolver }, { token: i1$1.OverlayContainerRef }, { token: i0.Injector }, { token: i0.ViewContainerRef }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });
ReadTipDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.3", type: ReadTipDirective, selector: "[dReadTip]", inputs: { readTipOptions: "readTipOptions", contentTemplate: "contentTemplate" }, host: { listeners: { "mouseover": "onMouseOver($event)", "mouseout": "onMouseOut($event)", "click": "onClick($event)" } }, exportAs: ["dReadTip"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: ReadTipDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dReadTip]',
                    exportAs: 'dReadTip',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ComponentFactoryResolver }, { type: i1$1.OverlayContainerRef }, { type: i0.Injector }, { type: i0.ViewContainerRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { readTipOptions: [{
                type: Input
            }], contentTemplate: [{
                type: Input
            }], onMouseOver: [{
                type: HostListener,
                args: ['mouseover', ['$event']]
            }], onMouseOut: [{
                type: HostListener,
                args: ['mouseout', ['$event']]
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

class ReadTipModule {
}
ReadTipModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: ReadTipModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ReadTipModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: ReadTipModule, declarations: [ReadTipComponent, ReadTipDirective], imports: [CommonModule, PositioningModule, OverlayContainerModule], exports: [ReadTipComponent, ReadTipDirective] });
ReadTipModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: ReadTipModule, imports: [[CommonModule, PositioningModule, OverlayContainerModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: ReadTipModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, PositioningModule, OverlayContainerModule],
                    exports: [ReadTipComponent, ReadTipDirective],
                    declarations: [ReadTipComponent, ReadTipDirective],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ReadTipComponent, ReadTipDirective, ReadTipModule };
//# sourceMappingURL=ng-devui-read-tip.mjs.map
