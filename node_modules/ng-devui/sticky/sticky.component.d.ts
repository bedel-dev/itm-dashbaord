import { AfterViewInit, ElementRef, EventEmitter, OnDestroy, OnInit } from '@angular/core';
import { WindowRef } from 'ng-devui/window-ref';
import { Subscription } from 'rxjs';
import * as i0 from "@angular/core";
export declare type StickyStatus = 'normal' | 'follow' | 'stay' | 'remain';
export declare class StickyComponent implements OnInit, AfterViewInit, OnDestroy {
    private el;
    private windowRef;
    hostPosition: string;
    zIndex: number;
    container: Element;
    view: {
        top?: number;
        bottom?: number;
    };
    scrollTarget: any;
    statusChange: EventEmitter<StickyStatus>;
    wrapper: any;
    _prevStatus: StickyStatus;
    _status: StickyStatus;
    set status(status: StickyStatus);
    get status(): StickyStatus;
    parentNode: any;
    containerLeft: any;
    private THROTTLE_DELAY;
    private THROTTLE_TRIGGER;
    private scrollPreStart;
    private scrollTimer;
    subscription: Subscription;
    constructor(el: ElementRef, windowRef: WindowRef);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    statusProcess(status: any): void;
    throttle: () => void;
    scrollAndResizeHock: () => void;
    scrollHandler: () => void;
    calculateRelativePosition(element: any, relativeElement: any, direction: any): number;
    calculateRemainPosition(element: any, relativeElement: any, container: any): number;
    initScrollStatus(target: any): void;
    /**
     * 提供给业务自己触发
     * 用法：
     * 1.捕获所有sticky：```@ViewChildren(StickyComponent) stickies;```
     * 2.触发刷新：当需要手动触发更新的时候，比如订阅数据返回后页面高度发生变化可以调用 ```stickies.forEach(sticky => sticky.recalculatePosition());```
     * 慎用，少用， 使用太多会影响性能。
     */
    recalculatePosition(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<StickyComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<StickyComponent, "d-sticky", never, { "zIndex": "zIndex"; "container": "container"; "view": "view"; "scrollTarget": "scrollTarget"; }, { "statusChange": "statusChange"; }, never, ["*"]>;
}
